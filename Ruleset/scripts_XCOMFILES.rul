# Script documentation:
#
# Item and Armor Energy Shields - HP buffers on handheld items and armors
# createUnit - offset: 1, createItem - offset: 1, newTurnUnit - offset: 2
# newTurnItem - offset: 2, hitUnit - offset: 1, hitUnit - offset: 2
#
#   Hits on units are reduced by the energy shield until it is depleted.
#   Item-based versions must be held in hand to reduce damage, and primed
#   like a grenade if the ITEM_ENERGY_SHIELD_NEEDS_PRIMING is set to a value
#   not equal to zero.
#   Other item-based parameters:
#     ITEM_ENERGY_SHIELD_CAPACITY - Initial HP value for the shield and maximum
#       with regeneration
#     ITEM_ENERGY_SHIELD_PER_TURN - How much the HP value changes every turn
#       (both player turn and enemy turn run the script so each full turn will
#        change shield HP by this value twice)
#     ITEM_ENERGY_SHIELD_TYPE - Used to determine the which set of 'resistances'
#       defined in the script will be used in calculating how effective the
#       shield is against various damage types
#     ITEM_ENERGY_SHIELD_FLASH_COLOR - Color group for flash when unit is hit
#     ITEM_ENERGY_SHIELD_INDICATOR_COLOR - Color group to use on the item's
#       sprite to indicate shield HP level
#     ITEM_ENERGY_SHIELD_COLOR_REPLACED_BY_INDICATOR - Color group on the item's
#       sprite to be replaced by the indicator color
#     ITEM_ENERGY_SHIELD_DOWN_COLOR - Indicator switches to this color group
#       when down
#
#   Armor-based parameters:
#     ARMOR_ENERGY_SHIELD_CAPACITY - Initial HP value for the shield and maximum
#       with regeneration
#     ARMOR_ENERGY_SHIELD_PER_TURN - How much the HP value changes every turn
#       (both player turn and enemy turn run the script so each full turn will
#        change shield HP by this value twice)
#     ARMOR_ENERGY_SHIELD_TYPE - Used to determine the which set of 'resistances'
#       defined in the script will be used in calculating how effective the
#       shield is against various damage types
#     ARMOR_ENERGY_SHIELD_FLASH_COLOR - Color group the unit will flash when hit
#
#   At the beginning of a battle, all armors and items with
#   ITEM_ENERGY_SHIELD_NEEDS_PRIMING: 0 will have their shield HP value set to
#   to the capacity tag. ITEM_ENERGY_SHIELD_NEEDS_PRIMING: 1 (or any other !=0
#   value) items will have their shield HP value set upon priming. At the
#   beginning of each turn, both player and enemy, excluding the first, the
#   shield HP value will be changed by the per turn tag, limited to the range
#   0-capacity.
#
#   On hit, shields take damage in the following order: left hand item, right
#   hand item, armor. The shield type tag is resolved into a set of resistances,
#   and the hit damage type is checked against a list of damage types that do
#   not interact with the shield. If it is one of those types, no further
#   calculations are done and all the damage passes through the shield. Next is
#   a list of damage types with a specific resistance value, written as a
#   percent susceptibility to that damage type. A value of 50 to damage type 4
#   means the shield takes half damage from lasers. Finally, if the hit's damage
#   type is not found on either of these lists, a default resistance value is
#   chosen.
#
#   Once the resistance is chosen, the remaining shield HP is modified into an
#   effective HP for that damage type - a shield with 100 HP and a resistance of
#   50 is effectively 200 HP for that damage type. The power of the hit is
#   subtracted from the effective HP value and the effective HP (before the
#   subtraction) is subtracted from the power. Both of these values are limited
#   to positive values. The leftover power is passed on to deal with the next
#   energy shield in the list or the unit's regular armor. The remaining
#   effective HP after the hit is converted back to the same units as before the
#   resistance modifier - a remaining effective HP of 80 on a shield with
#   resistance 50 will return to 40 shield HP.
#
#   If the hit is completely negated by the shield and shield HP is remaining,
#   the unit will flash the color given by the appropriate tag.
#
#
# Items granting per-turn stun, energy, and morale regeneration/degeneration
# newTurnItem - offset: 4
#
#   Every half-turn (beginning of both player and enemy turns, excluding the
#   first player turn), items with the tags ITEM_STUN_PER_TURN,
#   ITEM_ENERGY_PER_TURN, ITEM_MORALE_PER_TURN will check to see if they are in
#   the inventory of a unit, and if so, will change the value mentioned in the
#   nonzero tag by the amount in the tag, within the limits of 0 to the max
#   possible value.
#
# Item Physical Shield - damage reduction on handheld items, chance to block
# hitUnit - offset: 3
#
#   Hits on units are reduced according to the tag PHYSICAL_SHIELD_ARMOR, if an
#   item with that tag is in the unit's hand. Melee attacks have a chance to be
#   completely negated, according to the unit stats and the tags
#   ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT and ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT.
#   Melee attacks are considered hits with battle action type 10, BA_HIT or hits
#   from ranged weapons with the tag ITEM_IS_MELEE set not equal to 0.
#
#   When hit, a unit's hands are checked for an item with the PHYSICAL_SHIELD_ARMOR
#   tag, first the left and then the right. The dodge coefficients are taken
#   from the first item found with the armor tag set. Next, the type of damage
#   is compared to a list of damage types that should bypass physical shields -
#   if it is one of those types, the script returns at this point without
#   modifying damage. Next, melee hits take into account the dodge coefficients.
#   The unit's melee stat is multiplied by ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT as
#   a percentage, and the same is done for reactions and its coefficient, then
#   both are added together. A 0-100 dice roll is made, and if the roll is less
#   than this sum, then the power of the hit is set to 0 and the script returns.
#
#   Finally, the armor value of the physical shield item is modified by a set of
#   standard resistances (lower numbers mean the shield is more effective
#   against that damage type) and by a multiplier for the side of the unit that
#   was hit. This armor value is then subtracted from the power of the hit and
#   the script returns.
#
# Bonus Secondary Stats - Extra RNG roll to get secondary stats at end of mission:
# returnFromMissionUnit - offset: 1
#
#   If a unit gains experience during the mission, its armor is checked for the tag
#   ARMOR_GAINS_EXTRA_SECONDARY_STATS_PERCENT. If set, then for each of time units,
#   stamina, health, and strength, the difference between the unit's current stats
#   and the max for the soldier type is checked. If below the cap, then a RNG roll
#   between 0 and the difference between current and the cap, modified by the
#   percent value of the tag, capped at a minimum of 1, is made and added to the 
#   unit's stats.

#--------------------------------------------------------------------------------------------
# Items
#--------------------------------------------------------------------------------------------
items:
#Uses alphabetical order for resistances stacking, names should go worst to best; unique Index should follow that
#Unique index slots do not stack with each other, alphabetically first is used
#Slots breakdown:
# ITEM_RESIST_SLOT_INDEX: 1 - Back
# ITEM_RESIST_SLOT_INDEX: 2 - ???
# ITEM_RESIST_SLOT_INDEX: 3 - ???
# ITEM_RESIST_SLOT_INDEX: 4 - ???
# ITEM_RESIST_SLOT_INDEX: 5 - ???
# ITEM_RESIST_SLOT_INDEX: 6 - ???
# ITEM_RESIST_SLOT_INDEX: 7 - ???
# ITEM_RESIST_SLOT_INDEX: 8 - ???
# ITEM_RESIST_SLOT_INDEX: 9 - ???

#This is safe to delete, only if you want to test the mechanical repair or use as an example!
  # - type: STR_BLOWTORCH #Can be set on the Item if its clip-less OR on the magazine if it does have a clipsize
    # tags:
      # ITEM_REPAIR_KIT: 1
      # ITEM_REPAIR_KIT_POWER: 10
    # listOrder: 46110
  # - type: STR_LASER_BLOWTORCH_BATTERY #This is a clip/magazine with the tag in it example
    # tags:
      # ITEM_REPAIR_KIT: 1
      # ITEM_REPAIR_KIT_POWER: 20
  - type: STR_SHADOWBAT_WEAPON
    tags:
      YTAG_DAMAGE_RETURNED_AS_HP: 10
      YTAG_DAMAGE_RETURNED_RESIST_TYPE: 12
  - type: STR_VAMPIRE_BITE
    tags:
      YTAG_DAMAGE_RETURNED_AS_HP: 50
      YTAG_DAMAGE_RETURNED_RESIST_TYPE: 12
  - type: STR_FLASHBANG_GRENADE
    tags:
      FTAG_DAZE_VALUE: 100
      FTAG_DAZE_TIME: 1
  - type: STR_LAUNCHER_FLASHBANG
    tags:
      FTAG_DAZE_VALUE: 90 #percentage
      FTAG_DAZE_TIME: 1
  - type: STR_MILKOR_MGL_CLIP_FLASHBANG
    tags:
      FTAG_DAZE_VALUE: 90 #percentage
      FTAG_DAZE_TIME: 1
  - type: STR_WEBWEAR
    tags:
      ITEM_RESIST_TYPE_1: 80
      ITEM_MINIMUM_RESIST_TYPE_1: 50
      ITEM_RESIST_SLOT_INDEX: 1
  - type: STR_CARAPACE_PLATE
    tags:
      ITEM_RESIST_TYPE_3: 80
      ITEM_MINIMUM_RESIST_TYPE_3: 50
      ITEM_RESIST_SLOT_INDEX: 1

#--------------------------------------------------------------------------------------------
# Armors
#--------------------------------------------------------------------------------------------
armors:
  - type: STR_ALIEN_LASER_TURRET_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
      ARMOR_ENERGY_SHIELD_CAPACITY: 200
      ARMOR_ENERGY_SHIELD_PER_TURN: 50
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_SHADOWBAT_ARMOR
    tags:
      YTAG_DAMAGE_RETURNED_AS_HP_BUFF: 3
      YTAG_DAMAGE_RETURNED_AS_ENERGY_BUFF: 15
      YTAG_DAMAGE_RETURNED_RESIST_TYPE_ARMOR: 12
  - type: STR_XCOM_BAT_ARMOR
    tags:
      YTAG_DAMAGE_RETURNED_AS_HP_BUFF: 3
      YTAG_DAMAGE_RETURNED_AS_ENERGY_BUFF: 15
      YTAG_DAMAGE_RETURNED_RESIST_TYPE_ARMOR: 12
  - type: STR_VAMPIRE_QUEEN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
      YTAG_DAMAGE_RETURNED_AS_HP_BUFF: 50
      YTAG_DAMAGE_RETURNED_AS_ENERGY_BUFF: 25
      YTAG_DAMAGE_RETURNED_RESIST_TYPE_ARMOR: 12
  - type: STR_MUMMY_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
      ARMOR_ENERGY_SHIELD_CAPACITY: 100
      ARMOR_ENERGY_SHIELD_PER_TURN: 25
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 3
      ARMOR_ENERGY_SHIELD_TYPE: 1
  - type: STR_BLACK_LOTUS_WAR_WITCH_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 40
      ARMOR_ENERGY_SHIELD_PER_TURN: 20
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_BLACK_LOTUS_AVATAR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      ARMOR_ENERGY_SHIELD_CAPACITY: 50
      ARMOR_ENERGY_SHIELD_PER_TURN: 25
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_SOLDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      ARMOR_ENERGY_SHIELD_CAPACITY: 150
      ARMOR_ENERGY_SHIELD_PER_TURN: 25
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
      ARMOR_ENERGY_SHIELD_CAPACITY: 200
      ARMOR_ENERGY_SHIELD_PER_TURN: 35
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 250
      ARMOR_ENERGY_SHIELD_PER_TURN: 35
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_SERVITOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 150
      ARMOR_ENERGY_SHIELD_PER_TURN: 75
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_ELIMINATOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 130
      ARMOR_ENERGY_SHIELD_PER_TURN: 30
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_GUARDIAN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 200
      ARMOR_ENERGY_SHIELD_PER_TURN: 50
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_SPEAKER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 250
      ARMOR_ENERGY_SHIELD_PER_TURN: 25
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_KEEPER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 180
      ARMOR_ENERGY_SHIELD_PER_TURN: 22
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_LEGATE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 220
      ARMOR_ENERGY_SHIELD_PER_TURN: 20
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_KNIGHT_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 300
      ARMOR_ENERGY_SHIELD_PER_TURN: 75
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_ETHEREAL_GRAND_MASTER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
      ARMOR_ENERGY_SHIELD_CAPACITY: 500
      ARMOR_ENERGY_SHIELD_PER_TURN: 85
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_HYBRID_ARMOR
    tags: &hybridShield
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_HYBRID_SOLDIER_ARMOR
    tags: *hybridShield
  - type: STR_HYBRID_SPECIALIST_ARMOR
    tags: *hybridShield
  - type: STR_HYBRID_SUPERVISOR_ARMOR
    tags: *hybridShield
  - type: STR_SUPERLASKA_ARMOR
    tags: *hybridShield
  - type: STR_HYBRID_SCIENTIST_ARMOR
    tags:
      ARMOR_ENERGY_SHIELD_CAPACITY: 35
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_HYBRID_DIPLOMAT_ARMOR
    tags: &hybridDiplomatShield
      ARMOR_ENERGY_SHIELD_CAPACITY: 35
      ARMOR_ENERGY_SHIELD_PER_TURN: 6
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_HYBRID_ENVOY_ARMOR
    tags: *hybridDiplomatShield
  - type: STR_BRAINER_ARMOR
    tags:
      ARMOR_ENERGY_SHIELD_CAPACITY: 50
      ARMOR_ENERGY_SHIELD_PER_TURN: 8
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_GERTRUDE_ELLISON_ARMOR
    tags:
      ARMOR_ENERGY_SHIELD_CAPACITY: 35
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2 
  - type: STR_SUIT_H_UC
    tags: *hybridShield
  - type: STR_VEST_BUSINESS_SUIT_H_UC
    tags: *hybridShield
  - type: STR_CAVEMAN_DISGUISE_H_UC
    tags: *hybridShield
  - type: STR_OSIRON_GOON_DISGUISE_H_UC
    tags: *hybridShield
  - type: STR_SYNDICATE_AGENT_DISGUISE_H_UC
    tags: *hybridShield
  - type: STR_MONGORN_ANZUG_H_UC
    tags: *hybridShield
  - type: STR_LEATHER_COAT_H_UC
    tags: *hybridShield
  - type: STR_BULLETPROOF_COAT_H_UC
    tags: *hybridShield
  - type: STR_LABCOAT_H_UC
    tags: *hybridShield
  - type: STR_POLAR_SUIT_H_UC
    tags: *hybridShield
  - type: STR_NONE_H_UC
    tags: *hybridShield
  - type: STR_SWIMWEAR_H_UC
    tags: *hybridShield
  - type: STR_NIGHTOPS_ARMOR_H_UC
    tags: *hybridShield
  - type: STR_JUMPSUIT_H_UC
    tags: *hybridShield
  - type: STR_JUMPSUIT_GREEN_H_UC
    tags: *hybridShield
  - type: STR_JUMPSUIT_BROWN_H_UC
    tags: *hybridShield
  - type: STR_GRAVMODULE_ARMOR_H_UC
    tags: *hybridShield
  - type: STR_GRAVMODULE_ARMOR_GREEN_H_UC
    tags: *hybridShield
  - type: STR_GRAVMODULE_ARMOR_BROWN_H_UC
    tags: *hybridShield
  - type: STR_XCOM_LIQUIDATOR_ARMOR_H_UC
    tags: *hybridShield
  - type: STR_JUMP_ARMOR_H_UC
    tags: *hybridShield
  - type: STR_PERSONAL_ARMOR_H_UC
    tags: *hybridShield
  - type: STR_AQUATOID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
      ARMOR_ENERGY_SHIELD_CAPACITY: 25
      ARMOR_ENERGY_SHIELD_PER_TURN: 3
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SECTOID_STANDARD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
      ARMOR_ENERGY_SHIELD_CAPACITY: 50
      ARMOR_ENERGY_SHIELD_PER_TURN: 7
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SECTOID_MEDIC_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
      ARMOR_ENERGY_SHIELD_CAPACITY: 67
      ARMOR_ENERGY_SHIELD_PER_TURN: 10
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SECTOID_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
      ARMOR_ENERGY_SHIELD_CAPACITY: 100
      ARMOR_ENERGY_SHIELD_PER_TURN: 15
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SECTOID_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
      ARMOR_ENERGY_SHIELD_CAPACITY: 125
      ARMOR_ENERGY_SHIELD_PER_TURN: 15
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SECTOID_GUARDIAN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 35
      ARMOR_ENERGY_SHIELD_CAPACITY: 80
      ARMOR_ENERGY_SHIELD_PER_TURN: 20
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_MIB_PSI_OPS_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      ARMOR_ENERGY_SHIELD_CAPACITY: 125
      ARMOR_ENERGY_SHIELD_PER_TURN: 20
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 3
      ARMOR_ENERGY_SHIELD_TYPE: 1
  - type: STR_CEREBREAL_STANDARD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
      ARMOR_ENERGY_SHIELD_CAPACITY: 100
      ARMOR_ENERGY_SHIELD_PER_TURN: 10
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_CEREBREAL_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
      ARMOR_ENERGY_SHIELD_CAPACITY: 125
      ARMOR_ENERGY_SHIELD_PER_TURN: 15
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_CEREBREAL_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
      ARMOR_ENERGY_SHIELD_CAPACITY: 150
      ARMOR_ENERGY_SHIELD_PER_TURN: 20
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 9
      ARMOR_ENERGY_SHIELD_TYPE: 0
  - type: STR_CEREBREAL_LARVA_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_PONTIFF_OF_APOCALYPSE_ARMOR
    tags:
      ARMOR_ENERGY_SHIELD_CAPACITY: 50
      ARMOR_ENERGY_SHIELD_PER_TURN: 20
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 2
      ARMOR_ENERGY_SHIELD_TYPE: 3
  - type: STR_SAMAEL_OF_APOCALYPSE_ARMOR
    tags:
      ARMOR_ENERGY_SHIELD_CAPACITY: 100
      ARMOR_ENERGY_SHIELD_PER_TURN: 50
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 2
      ARMOR_ENERGY_SHIELD_TYPE: 3
  - type: STR_ALIEN_BRAIN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_MEGAWORM_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80 # 100 means immune to flashbang daze, lower means %
  - type: STR_SWARMIDS_LARGE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 90
  - type: STR_SWARMIDS_SMALL_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 90
  - type: STR_JANISSARY_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_GILLDOG_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GILLDOG_ARMOR_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_BIODRONE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
  - type: STR_MERIDIAN_HUNTER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_SILACOID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_CELATID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_OOZE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_ABOMINATION_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_HORROR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_CHRYSSALID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
  - type: STR_BADASS_CHRYSSALID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
  - type: STR_DEEP_ONE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_DEEP_ONE_ARMOR_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_CALCINITE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_CARCHARODON_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_CARCHARODON_FERAL_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_TASOTH_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_LOBSTERMAN_FERAL_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_LOBSTERMAN_FERAL_ARMOR_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_LOBSTERMAN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_LOBSTERMAN_ARMOR_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_HALLUCINOID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_ANTHROPOD_SOLDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ANTHROPOD_NAVIGATOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ANTHROPOD_ENGINEER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_SPITTER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_SPITTER_RETRACT_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_SPITTER_RETRES_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_SPITTER_NAKED_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_FLOATER_SOLDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLOATER_ARMOR_GREEN
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLOATER_ARMOR_BLUE
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLOATER_ARMOR_WHITE
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLOATER_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLOATER_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLOATER_LEGIONNAIRE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_SNAKEMAN_SOLDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 35
  - type: STR_SNAKEMAN_ARMOR_GREEN
    tags:
      FTAG_FLASHBANG_RESISTANCE: 35
  - type: STR_SNAKEMAN_ARMOR_BLACK
    tags:
      FTAG_FLASHBANG_RESISTANCE: 35
  - type: STR_SNAKEMAN_ARMOR_BLUE
    tags:
      FTAG_FLASHBANG_RESISTANCE: 35
  - type: STR_SNAKEMAN_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 35
  - type: STR_SNAKEMAN_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 35
  - type: STR_MUTON_SOLDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MUTON_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MUTON_ENGINEER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MUTON_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MUTON_NAVIGATOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MUTON_SHADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_CHASER_STANDARD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_TENTACULAT_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_CHTONITE_STANDARD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_GAZER_STANDARD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_GAZER_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_GAZER_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_HOLODRONE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_WASPITE_STANDARD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_WASPITE_ARMOR_BROWN
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_WASPITE_ARMOR_WHITE
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_WASPITE_LEADER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_WASPITE_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_THE_THING_HEAD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_THE_THING_POLARNIK_ARMOR
    tags:
      FTAG_ROTTINGMIN: 4
      FTAG_ROTTINGMAX: 10
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_THE_THING_POLARNIK_TRANSFORMED_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_THE_THING_DOG_ARMOR
    tags:
      FTAG_ROTTINGMIN: 2
      FTAG_ROTTINGMAX: 6
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_THE_THING_SHAPELESS_MASS_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_SCORPOID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ANTMAN_WORKER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ANTMAN_WARRIOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ANTMAN_QUEEN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_SALAMANDRON_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_CROC_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_MALE_VIP_REPTOID_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_REPTOID_STANDARD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_REPTOID_COMMANDO_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_REPTOID_SHADOW_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_PHARAOH_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_REPTOID_DRAKE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_REPTOID_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MUCKSTAR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_JARHEAD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_JARHEAD_PRETENDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_BLACK_LOTUS_MASHINOBI_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_ZOMBIE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_MEGASCORPION_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_BEETLE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_BEETLE_BOMBARDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_SPIDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_SPIDER_ALLOY_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_SPIDER_PURPLE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_SPIDER_GREEN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_SPIDER_RED_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_SPIDER_QUEEN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GIANT_SPIDER_KING_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GHOUL_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_GHOUL_WARRIOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ZOMBIE_BOOMER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ZOMBIE_STERILE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ZOMBIE_GRUBAS_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ZOMBIE_INFECTOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_STRIX_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_TOMB_GUARD_FEMALE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_TOMB_GUARD_MALE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_VAMPIRE_KNIGHT_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_ZOMBIE_TROOPER_1_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_ZOMBIE_TROOPER_2_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_MEGAZOMBIE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ZOMBIE_DOGE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_BUG_EYE_GHOST_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_SKULL_WRAITH_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_DREAMSPRITE_ARMOR_RED
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_MIB_ENFORCER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 15
  - type: STR_MIB_COMBAT_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_MIB_COORDINATOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 15
  - type: STR_MIB_COMMANDER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 15
  - type: STR_MIB_POWER_SUIT
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MIB_STORMTROOPER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_MOTOR_MAN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_SYNDICATE_MERC_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_SYNDICATE_MERC_CAPTAIN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_CYBERWEB_TECHNOMAD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_CYBERWEB_MYSTEK_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_CYBERWEB_SPACE_TECHNOMAD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_EXALT_ENFORCER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ZSRR_UBEK_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_BLACK_LOTUS_WARRIOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 15
  - type: STR_BLACK_LOTUS_ASSASSIN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_BLACK_LOTUS_MANDARIN_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_LO_WO_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_SORCERER_OF_DAGON_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_MALE_ENGINEER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 5
  - type: STR_MALE_SOLDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_MALE_ELITE_SOLDIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_CRISIS_TROOPER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_MALE_MAGMA_HEAVY_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_MALE_MAGMA_SECURITY_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_FEMALE_MAGMA_SECURITY_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 20
  - type: STR_ASTRONAUT_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 45
  - type: STR_COUNCIL_SALVAGER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 25
  - type: STR_XCOM_ROBOTURRET_MINIGUN_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_XCOM_ROBOTURRET_LASER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_XCOM_ROBOTURRET_PLASMA_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_REPTOID_DRAGONFIRE_TURRET_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
  - type: STR_SEEKER_DRONE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 80
  - type: STR_CYBERWEB_ROBOSPHERE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_CYBERWEB_ROBOTURRET_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_CYBERWEB_CENTURION_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_SYNDICATE_WALKER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_MAGMA_CHAINSAWBOT_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_MAGMA_ROBOTANK_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_MAGMA_MINITANK_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_OBLITERATOR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_SECTOPOD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_MIB_SECTOPOD_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_CYBERDISC_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_CYBERMITE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_ALIEN_DRONE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_LARGE_ALIEN_DRONE_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_XCOM_FLYING_DRONE_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_SEABOT_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_SMALL_TANK_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_MEDICAL_DRONE_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_COELACANTH_ARMOR_UC
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_CANNON_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_ROCKET_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_TRITANIUM_ROCKET_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_MINIGUN_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_LASER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_PLASMA_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_MASS_DRIVER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_GAUSS_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_LASER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_PLASMA_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_ROCKET_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_TRITANIUM_ROCKET_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_LAUNCHER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_MASS_DRIVER_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_GAUSS_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TANK_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HOVERTANK_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_SECTOPOD_ARMOR2
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_SECTOPOD_ARMOR3
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_SECTOPOD_MINIGUN_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_MIBTANK_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_XCOM_CYBERDISC_ARMOR
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_XCOM_CYBERDISC_ARMOR_ORANGE
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 100
  - type: STR_ARMORED_CAR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_ARMY_ARMORED_CAR_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_GUNSHIP_ARMOR_UC
    tags:
      ARMOR_IS_MECHANICAL: 1
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_SMALL_TANK_ROCKET_LAUNCHER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_OUTRUNNER_ARMOR_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_HOVERTANK_MINIROCKET_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_HOVERTANK_FLAMER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_TANK_MINIROCKET_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_TANK_FLAMER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_TANK_CARRIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_HOVERTANK_CARRIER_ARMOR
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_ENFORCER_ARMOR_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_IS_MECHANICAL: 1
  - type: STR_WORKSUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 5
  - type: STR_WORKSUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 5
  - type: STR_WORKSUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 5
  - type: STR_WORKSUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 5
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_BIOEXO_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_BIOEXO_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_BIOEXO_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_BIOEXO_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_HEAVY_TACTICAL_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_HEAVY_TACTICAL_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_HEAVY_TACTICAL_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_HEAVY_TACTICAL_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_HEAVY_TRITANIUM_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_HEAVY_TRITANIUM_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_HEAVY_TRITANIUM_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
  - type: STR_HEAVY_TRITANIUM_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 50
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_ARMORED_VEST_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ARMORED_VEST_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ARMORED_VEST_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ARMORED_VEST_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_ARMORED_VEST_SHIELD_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ARMORED_VEST_SHIELD_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ARMORED_VEST_SHIELD_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ARMORED_VEST_SHIELD_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_ALLOY_VEST_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ALLOY_VEST_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ALLOY_VEST_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ALLOY_VEST_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_ALLOY_VEST_SHIELD_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ALLOY_VEST_SHIELD_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ALLOY_VEST_SHIELD_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_ALLOY_VEST_SHIELD_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_HAZMAT_ARMOR_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HAZMAT_ARMOR_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HAZMAT_ARMOR_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_HAZMAT_ARMOR_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_TOXI_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TOXI_SUIT_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TOXI_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TOXI_SUIT_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TOXI_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TOXI_SUIT_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_TOXI_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_TOXI_SUIT_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_CYBER_ARMOR_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_CYBER_ARMOR_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_CYBER_ARMOR_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_CYBER_ARMOR_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SYNTHSUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_SYNTHSUIT_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_SYNTHSUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_SYNTHSUIT_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_SYNTHSUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_SYNTHSUIT_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
  - type: STR_SYNTHSUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SYNTHSUIT_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 10
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_ASSAULT_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_ASSAULT_SUIT_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_ASSAULT_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_ASSAULT_SUIT_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_ASSAULT_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_ASSAULT_SUIT_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
  - type: STR_ASSAULT_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_ASSAULT_SUIT_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 60
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_POWER_ARMOR_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_ARMOR_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_ARMOR_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_ARMOR_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_ARMOR_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_ARMOR_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_ARMOR_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_POWER_ARMOR_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_POWER_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_SUIT_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_SUIT_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_SUIT_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_POWER_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_POWER_SUIT_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_FLYING_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_FLYING_SUIT_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_FLYING_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_FLYING_SUIT_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_FLYING_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_FLYING_SUIT_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_FLYING_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_FLYING_SUIT_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_STORMTROOPER_ARMOR_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_STORMTROOPER_ARMOR_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_STORMTROOPER_ARMOR_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_STORMTROOPER_ARMOR_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_STORMTROOPER_ARMOR_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_STORMTROOPER_ARMOR_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_STORMTROOPER_ARMOR_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_STORMTROOPER_ARMOR_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_JUGGERNAUT_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_JUGGERNAUT_SUIT_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_JUGGERNAUT_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_JUGGERNAUT_SUIT_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_JUGGERNAUT_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_JUGGERNAUT_SUIT_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
  - type: STR_JUGGERNAUT_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_JUGGERNAUT_SUIT_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 70
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_DIVING_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_DIVING_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_DIVING_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_DIVING_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_AQUA_PLASTIC_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_AQUA_PLASTIC_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_AQUA_PLASTIC_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_AQUA_PLASTIC_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_AQUA_PLASTIC_SUIT_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_AQUA_PLASTIC_SUIT_OLYMPIAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_AQUA_PLASTIC_SUIT_PROTEAN_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
  - type: STR_AQUA_PLASTIC_SUIT_H_UC_UNDERWATER
    tags:
      FTAG_FLASHBANG_RESISTANCE: 30
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_SPACE_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_SPACE_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_SPACE_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_SPACE_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2
  - type: STR_FLYING_SPACE_SUIT_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLYING_SPACE_SUIT_OLYMPIAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLYING_SPACE_SUIT_PROTEAN_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
  - type: STR_FLYING_SPACE_SUIT_H_UC
    tags:
      FTAG_FLASHBANG_RESISTANCE: 40
      ARMOR_ENERGY_SHIELD_CAPACITY: 20
      ARMOR_ENERGY_SHIELD_PER_TURN: 4
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: 12
      ARMOR_ENERGY_SHIELD_TYPE: 2

#--------------------------------------------------------------------------------------------
# Scripting stuff
#--------------------------------------------------------------------------------------------
extended:
  tags: # Remember to add tag definitions to same file as item/armor rulesets!
#--------------------------------------------------------------------------------------------
# RuleItem tags
#--------------------------------------------------------------------------------------------
    RuleItem:
#vampiric
      YTAG_DAMAGE_RETURNED_AS_HP: int
      YTAG_DAMAGE_RETURNED_AS_ENERGY: int
      YTAG_DAMAGE_RETURNED_AS_TIME: int
      YTAG_DAMAGE_RETURNED_AS_MORALE: int
      YTAG_DAMAGE_RETURNED_AS_STUN: int
      YTAG_DAMAGE_RETURNED_RESIST_TYPE: int
#defense
      PHYSICAL_SHIELD_ARMOR: int
      ITEM_IS_MELEE: int
      ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT: int
      ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT: int
      ITEM_RESIST_SLOT_INDEX: int
      ITEM_RESIST_TYPE_0: int
      ITEM_RESIST_TYPE_1: int
      ITEM_RESIST_TYPE_2: int
      ITEM_RESIST_TYPE_3: int
      ITEM_RESIST_TYPE_4: int
      ITEM_RESIST_TYPE_5: int
      ITEM_RESIST_TYPE_6: int
      ITEM_RESIST_TYPE_7: int
      ITEM_RESIST_TYPE_8: int
      ITEM_RESIST_TYPE_9: int
      ITEM_RESIST_TYPE_10: int
      ITEM_RESIST_TYPE_11: int
      ITEM_RESIST_TYPE_12: int
      ITEM_RESIST_TYPE_13: int
      ITEM_RESIST_TYPE_14: int
      ITEM_RESIST_TYPE_15: int
      ITEM_RESIST_TYPE_16: int
      ITEM_RESIST_TYPE_17: int
      ITEM_RESIST_TYPE_18: int
      ITEM_RESIST_TYPE_19: int
      ITEM_MINIMUM_RESIST_TYPE_0: int
      ITEM_MINIMUM_RESIST_TYPE_1: int
      ITEM_MINIMUM_RESIST_TYPE_2: int
      ITEM_MINIMUM_RESIST_TYPE_3: int
      ITEM_MINIMUM_RESIST_TYPE_4: int
      ITEM_MINIMUM_RESIST_TYPE_5: int
      ITEM_MINIMUM_RESIST_TYPE_6: int
      ITEM_MINIMUM_RESIST_TYPE_7: int
      ITEM_MINIMUM_RESIST_TYPE_8: int
      ITEM_MINIMUM_RESIST_TYPE_9: int
      ITEM_MINIMUM_RESIST_TYPE_10: int
      ITEM_MINIMUM_RESIST_TYPE_11: int
      ITEM_MINIMUM_RESIST_TYPE_12: int
      ITEM_MINIMUM_RESIST_TYPE_13: int
      ITEM_MINIMUM_RESIST_TYPE_14: int
      ITEM_MINIMUM_RESIST_TYPE_15: int
      ITEM_MINIMUM_RESIST_TYPE_16: int
      ITEM_MINIMUM_RESIST_TYPE_17: int
      ITEM_MINIMUM_RESIST_TYPE_18: int
      ITEM_MINIMUM_RESIST_TYPE_19: int
      ITEM_ENERGY_SHIELD_NEEDS_PRIMING: int
      ITEM_ENERGY_SHIELD_CAPACITY: int
      ITEM_ENERGY_SHIELD_PER_TURN: int
      ITEM_ENERGY_SHIELD_TYPE: int
      ITEM_ENERGY_SHIELD_FLASH_COLOR: int # Color group for flash when unit is hit
      ITEM_ENERGY_SHIELD_INDICATOR_COLOR: int # Color group for item's indicator
      ITEM_ENERGY_SHIELD_COLOR_REPLACED_BY_INDICATOR: int # Color group that is replaced by indicator
      ITEM_ENERGY_SHIELD_DOWN_COLOR: int # Indicator switches to this color group when down
      #COLOR_X1_BLUE0 7
      #COLOR_X1_BLUE1 8
      #COLOR_X1_BLUE2 13
      #COLOR_X1_BROWN0 6
      #COLOR_X1_BROWN1  9
      #COLOR_X1_BROWN2  10
      #COLOR_X1_FACE  9
      #COLOR_X1_GRAY  5
      #COLOR_X1_GREEN0 3
      #COLOR_X1_GREEN1 4
      #COLOR_X1_HAIR 6
      #COLOR_X1_NULL 0
      #COLOR_X1_PURPLE0 11
      #COLOR_X1_PURPLE1 12
      #COLOR_X1_RED 2
      #COLOR_X1_SILVER 14
      #COLOR_X1_SPECIAL 15
      #COLOR_X1_YELLOW  1
      ITEM_STUN_PER_TURN: int
      ITEM_ENERGY_PER_TURN: int
      ITEM_MORALE_PER_TURN: int
#flashbangs
      FTAG_DAZE_VALUE: int
      FTAG_DAZE_TIME: int
      FTAG_TOPSIKER_ADD_POWER: int
#bondage
      HANDCUFF_POWER: int #the handcuff strength in ruleset for items
#boosting
      WM_IS_WACKY: int
#Mechanical Repair
      ITEM_REPAIR_KIT: int
      ITEM_REPAIR_KIT_POWER: int

#--------------------------------------------------------------------------------------------
# RuleArmor tags
#--------------------------------------------------------------------------------------------
    RuleArmor:
#rotting
      FTAG_ROTTINGMIN: int
      FTAG_ROTTINGMAX: int
#flashbang res
      FTAG_FLASHBANG_RESISTANCE: int
#vampiric
      YTAG_DAMAGE_RETURNED_AS_HP_BUFF: int
      YTAG_DAMAGE_RETURNED_AS_ENERGY_BUFF: int
      YTAG_DAMAGE_RETURNED_AS_TIME_BUFF: int
      YTAG_DAMAGE_RETURNED_AS_MORALE_BUFF: int
      YTAG_DAMAGE_RETURNED_AS_STUN_BUFF: int
      YTAG_DAMAGE_RETURNED_RESIST_TYPE_ARMOR: int
#defense      
      ARMOR_ENERGY_SHIELD_CAPACITY: int
      ARMOR_ENERGY_SHIELD_PER_TURN: int
      ARMOR_ENERGY_SHIELD_TYPE: int
      ARMOR_ENERGY_SHIELD_FLASH_COLOR: int # Color group for flash when unit is hit
#other buffs
      ARMOR_GAINS_EXTRA_SECONDARY_STATS_PERCENT: int
#bondage
      HANDCUFF_PROTECTION: int #the handcuff protection in ruleset for units
#Mechanical Repair
      ARMOR_IS_MECHANICAL: int

#--------------------------------------------------------------------------------------------
# BattleItem tags
#--------------------------------------------------------------------------------------------
    BattleItem:
#portable shields
      ITEM_ENERGY_SHIELD_HP: int
      ITEM_ENERGY_SHIELD_IS_PRIMED: int
#bondage
      ITEM_HANDCUFF_POWER: int #the handcuff strength for every copy of item in battlescape

#--------------------------------------------------------------------------------------------
# RuleUnit tags
#--------------------------------------------------------------------------------------------
    BattleUnit:
#resistances
      UNIT_RESIST_ITEM_SLOT_1: int
      UNIT_RESIST_ITEM_SLOT_2: int
      UNIT_RESIST_ITEM_SLOT_3: int
      UNIT_RESIST_ITEM_SLOT_4: int
      UNIT_RESIST_ITEM_SLOT_5: int
      UNIT_RESIST_ITEM_SLOT_6: int
      UNIT_RESIST_ITEM_SLOT_7: int
      UNIT_RESIST_ITEM_SLOT_8: int
      UNIT_RESIST_ITEM_SLOT_9: int
      UNIT_RESIST_ITEM_SLOT_10: int
      UNIT_RESIST_ITEM_SLOT_11: int
      UNIT_RESIST_ITEM_SLOT_12: int
      UNIT_RESIST_ITEM_SLOT_13: int
      UNIT_RESIST_ITEM_SLOT_14: int
      UNIT_RESIST_ITEM_SLOT_15: int
      UNIT_RESIST_ITEM_SLOT_16: int
      UNIT_RESIST_ITEM_SLOT_17: int
      UNIT_RESIST_ITEM_SLOT_18: int
      UNIT_RESIST_ITEM_SLOT_19: int
      UNIT_RESIST_ITEM_SLOT_20: int
      UNIT_RESIST_TYPE_0: int
      UNIT_RESIST_TYPE_1: int
      UNIT_RESIST_TYPE_2: int
      UNIT_RESIST_TYPE_3: int
      UNIT_RESIST_TYPE_4: int
      UNIT_RESIST_TYPE_5: int
      UNIT_RESIST_TYPE_6: int
      UNIT_RESIST_TYPE_7: int
      UNIT_RESIST_TYPE_8: int
      UNIT_RESIST_TYPE_9: int
      UNIT_RESIST_TYPE_10: int
      UNIT_RESIST_TYPE_11: int
      UNIT_RESIST_TYPE_12: int
      UNIT_RESIST_TYPE_13: int
      UNIT_RESIST_TYPE_14: int
      UNIT_RESIST_TYPE_15: int
      UNIT_RESIST_TYPE_16: int
      UNIT_RESIST_TYPE_17: int
      UNIT_RESIST_TYPE_18: int
      UNIT_RESIST_TYPE_19: int
      UNIT_ENERGY_SHIELD_HP: int
      UNIT_RECOLOR_DESYNC: int
      UNIT_RECOLOR_COLOR: int
      UNIT_RECOLOR_START_FRAME: int
      UNIT_RECOLOR_FRAME_LENGTH: int

#flashbang
      FTAG_ISDAZED: int
      LAST_HIT_FRAME: int
      FTAG_DAZE_ENDTURN: int
      FTAG_DAZE_ORIGINAL_TIMEUNITS: int
      FTAG_DAZE_ORIGINAL_REACTIONS: int
      FTAG_DAZE_ORIGINAL_FIRING: int
      FTAG_DAZE_ORIGINAL_THROWING: int
      FTAG_DAZE_ORIGINAL_MELEE: int

#bondage
      UNIT_HANDCUFF_PROTECTION: int #the handcuff protection for every copy of unit in battlescape
      UNIT_HANDCUFF_LEVEL: int #how much handcuff strength used for handcuffing this unit
      VIRTUAL_STUN_LEVEL: int #real stunlevel for every copy of unit on battlescape

#Mechanical Repair
      UNIT_REPAIR_LIMIT: int
      UNIT_CURRENT_REPAIR: int
      UNIT_IS_MECHANICAL: int

#--------------------------------------------------------------------------------------------
# Scripts
#--------------------------------------------------------------------------------------------
  scripts:
    damageUnit:
      - offset: 1 #Flashbang damage script
        code: |
          var ptr RuleItem itemRuleset;
          var ptr RuleArmor armor_rule;
          var int dazeTag;
          var int animFrame;
          var int susceptibility;
          var int applyChance;
          var int dazeValue;
          var int statValue;
          var int debuffValue;
          var int dazeTime;
          var int endTurn;

          damaging_item.getRuleItem itemRuleset; #get debuff stats from item
          itemRuleset.getTag dazeValue Tag.FTAG_DAZE_VALUE;
          itemRuleset.getTag dazeTime Tag.FTAG_DAZE_TIME;
          if eq dazeValue 0; # Make sure item has daze effect
            return;
          end;          

          unit.getTag dazeTag Tag.FTAG_ISDAZED;
          if eq dazeTag 69; # Make sure unit already have daze debuff
            return;
          end;

          unit.getRuleArmor armor_rule;
          armor_rule.getTag susceptibility Tag.FTAG_FLASHBANG_RESISTANCE;
          battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
          if gt susceptibility applyChance; # check if target resist daze
            return;
          end;

          set dazeTag 69; #set dazed tag
          unit.setTag Tag.FTAG_ISDAZED dazeTag;
          battle_game.flashMessage "STR_TARGET_IS_DAZED";
          battle_game.getAnimFrame animFrame;
          unit.setTag Tag.LAST_HIT_FRAME animFrame;

            unit.Stats.getTimeUnits statValue; #remember original TimeUnits stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS statValue;
            div statValue 2; #calculate TimeUnits debuff, dividing it by 2
            unit.Stats.setTimeUnits statValue; #apply debuff

            unit.getTimeUnits statValue; #also divide actual TUs by 3
            div statValue 3;
            unit.setTimeUnits statValue;

            unit.Stats.getReactions statValue; #remember original Reactions stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_REACTIONS statValue;
            battle_game.randomRange debuffValue 25 35; #calculate random, 25-35 for Reactions
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setReactions statValue; #apply Reactions  debuff

            unit.Stats.getFiring statValue; #remember original Firing stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_FIRING statValue;
            battle_game.randomRange debuffValue 20 30; #calculate random, 20-30 for Firing
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setFiring statValue; #apply debuff

            unit.Stats.getThrowing statValue; #remember original Throwing stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_THROWING statValue;
            battle_game.randomRange debuffValue 20 30; #calculate random, 20-30 for Throwing
            muldiv debuffValue dazeValue 100; #calculate debuff
            sub statValue debuffValue;
            unit.Stats.setThrowing statValue; #apply debuff

            unit.Stats.getMelee statValue; #remember original Melee stat
            unit.setTag Tag.FTAG_DAZE_ORIGINAL_MELEE statValue;
            battle_game.randomRange debuffValue 10 20; #calculate random, 10-20 for Melee
            muldiv debuffValue dazeValue 100;
            sub statValue debuffValue;
            unit.Stats.setMelee statValue; #apply debuff

            battle_game.getTurn endTurn;
            add endTurn dazeTime; #define end turn for debuff
            unit.setTag Tag.FTAG_DAZE_ENDTURN endTurn;

          return;

      - offset: 3
        code: |
          var ptre BattleUnit attackingUnit;
          var ptre BattleItem attackingItem;
          var ptr RuleItem itemRuleset;
          var ptr RuleArmor attackerArmor;
          var int hpReturnedCoefficient;
          var int energyReturnedCoefficient;
          var int timeReturnedCoefficient;
          var int moraleReturnedCoefficient;
          var int stunReturnedCoefficient;
          var int damageReturnedResistType;
          var int hpDamageDone;
          var int hpTarget;
          var int statAttacker;
          var int statMaxAttacker;
          var int hpReturned;
          var int energyReturned;
          var int timeReturned;
          var int moraleReturned;
          var int stunReturned;
          var int temp;

          damaging_item.getRuleItem itemRuleset;
          itemRuleset.getTag hpReturnedCoefficient Tag.YTAG_DAMAGE_RETURNED_AS_HP;
          itemRuleset.getTag energyReturnedCoefficient Tag.YTAG_DAMAGE_RETURNED_AS_ENERGY;
          itemRuleset.getTag timeReturnedCoefficient Tag.YTAG_DAMAGE_RETURNED_AS_TIME;
          itemRuleset.getTag moraleReturnedCoefficient Tag.YTAG_DAMAGE_RETURNED_AS_MORALE;
          itemRuleset.getTag stunReturnedCoefficient Tag.YTAG_DAMAGE_RETURNED_AS_STUN;

          # check weapon for resist type
          itemRuleset.getTag damageReturnedResistType Tag.YTAG_DAMAGE_RETURNED_RESIST_TYPE;

          # following only if armor provides bonus
          damaging_item.getOwner attackingUnit;
          attackingUnit.getRuleArmor attackerArmor;
          if eq damageReturnedResistType 0;
            attackerArmor.getTag damageReturnedResistType Tag.YTAG_DAMAGE_RETURNED_RESIST_TYPE_ARMOR;
            attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_HP_BUFF;
            add hpReturnedCoefficient temp;
            attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_ENERGY_BUFF;
            add energyReturnedCoefficient temp;
            attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_TIME_BUFF;
            add timeReturnedCoefficient temp;
            attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_MORALE_BUFF;
            add moraleReturnedCoefficient temp;
            attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_STUN_BUFF;
            add stunReturnedCoefficient temp;
          else;
            attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_RESIST_TYPE_ARMOR;
            if eq temp damageReturnedResistType;
              attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_HP_BUFF;
              add hpReturnedCoefficient temp;
              attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_ENERGY_BUFF;
              add energyReturnedCoefficient temp;
              attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_TIME_BUFF;
              add timeReturnedCoefficient temp;
              attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_MORALE_BUFF;
              add moraleReturnedCoefficient temp;
              attackerArmor.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_STUN_BUFF;
              add stunReturnedCoefficient temp;
            end;
          end;

          # following only if extra held items are to provide bonus
          attackingUnit.getLeftHandWeapon attackingItem;

          if and neq attackingItem null neq attackingItem damaging_item;
            attackingItem.getRuleItem itemRuleset;
            itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_RESIST_TYPE;

            if eq damageReturnedResistType 0;
              set damageReturnedResistType temp;
            end;

            if eq damageReturnedResistType temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_HP;
              add hpReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_ENERGY;
              add energyReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_TIME;
              add timeReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_MORALE;
              add moraleReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_STUN;
              add stunReturnedCoefficient temp;
            end;
          end;

          attackingUnit.getRightHandWeapon attackingItem;

          if and neq attackingItem null neq attackingItem damaging_item;
            attackingItem.getRuleItem itemRuleset;
            itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_RESIST_TYPE;

            if eq damageReturnedResistType 0;
              set damageReturnedResistType temp;
            end;

            if eq damageReturnedResistType temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_HP;
              add hpReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_ENERGY;
              add energyReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_TIME;
              add timeReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_MORALE;
              add moraleReturnedCoefficient temp;
              itemRuleset.getTag temp Tag.YTAG_DAMAGE_RETURNED_AS_STUN;
              add stunReturnedCoefficient temp;
            end;
          end;

          # check if target not immune to vampirism
          set temp 100;
          unit.reduceByResistance temp damageReturnedResistType;
          if eq temp 0;
            return;
          end;

          # check if attacker has req. vampiric coeffs          
          if and eq hpReturnedCoefficient 0 eq energyReturnedCoefficient 0 eq timeReturnedCoefficient 0 eq moraleReturnedCoefficient 0 eq stunReturnedCoefficient 0;
            return;
          else;
            
            # set amount of HP drained, and that it can't be higher than target's total          
            unit.getHealth hpTarget;
            set hpDamageDone to_health;
            limit_upper hpDamageDone hpTarget;
            set hpReturned hpDamageDone;
            set energyReturned hpDamageDone;
            set timeReturned hpDamageDone;
            set moraleReturned hpDamageDone;
            set stunReturned hpDamageDone;

            # multiply damage returned to attacker as drain with coefs; muldiv is a*b/c
            muldiv hpReturned hpReturnedCoefficient 100;
            muldiv energyReturned energyReturnedCoefficient 100;
            muldiv timeReturned timeReturnedCoefficient 100;
            muldiv moraleReturned moraleReturnedCoefficient 100;
            muldiv stunReturned stunReturnedCoefficient 100;

            # factor in specified resistance
            unit.reduceByResistance hpReturned damageReturnedResistType;
            unit.reduceByResistance energyReturned damageReturnedResistType;
            unit.reduceByResistance timeReturned damageReturnedResistType;
            unit.reduceByResistance moraleReturned damageReturnedResistType;
            unit.reduceByResistance stunReturned damageReturnedResistType;

            # set the appropriate stats, respecting the maximum values
            attackingUnit.getHealth statAttacker;
            attackingUnit.getHealthMax statMaxAttacker;
            add hpReturned statAttacker;
            limit_upper hpReturned statMaxAttacker;
            attackingUnit.setHealth hpReturned;

            attackingUnit.getEnergy statAttacker;
            attackingUnit.getEnergyMax statMaxAttacker;
            add energyReturned statAttacker;
            limit_upper energyReturned statMaxAttacker;
            attackingUnit.setEnergy energyReturned;

            attackingUnit.getTimeUnits statAttacker;
            attackingUnit.getTimeUnitsMax statMaxAttacker;
            add timeReturned statAttacker;
            limit_upper timeReturned statMaxAttacker;
            attackingUnit.setTimeUnits timeReturned;

            # special case, morale return is influenced by bravery
            #if neq moraleReturned 0;
            #  attackingUnit.reduceByBravery moraleReturned;
            #end;
            attackingUnit.getMorale statAttacker;
            add moraleReturned statAttacker;
            limit_upper moraleReturned 100;
            attackingUnit.setMorale moraleReturned;

            attackingUnit.getStun statAttacker;
            sub statAttacker stunReturned;
            limit_lower stunReturned 0;
            attackingUnit.setStun statAttacker;
          end;

          return;
    # Global fix to Transformation attacks like Chryssalid zombification
    # Requires at least 1 hit point of damage before zombification triggers
    # This applies to *every* weapon that zombifies.  It *has* to get through armor to work.
      - offset: 4
        code: |
          if gt to_transform 0;
            if eq to_health 0;
              set to_transform 0;
            end;
          end;
          return;

    # Sanity loss mitigation from high Bravery:
      - offset: 6
        code: |
          var ptr RuleDamageType itemDamageRuleset;
          var ptr RuleItem damagingRuleItem;
          var ptr BattleItem insanityAura;
          var int sanityDamage;
          var int unitBravery;
          var int applyChance;

          if and eq side 3 eq damaging_type 0; #Side 3 and damage type 0 means its an aura effect
            # debug_log "Side was 3 and damaging type 0, Aura effects";
            # debug_log "The damage to Sanity is ";
            # debug_log to_mana;
            unit.Stats.getBravery unitBravery;
            # debug_log "This unit's bravery is ";
            # debug_log unitBravery;
            if ge unitBravery 100; #If unit has 100 bravery this will happen # Rolls can only get additional ones ONLY if they succeed, if they fail they will only get up to the one they got 
              # debug_log "Unit has 100 or more bravery!";
              set sanityDamage to_mana;
              if eq unitBravery 100; #Has a 75% chance to reduce Sanity damage by 1
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "apply chance is:";
              # debug_log applyChance;
              if gt 25 applyChance; # 75% chance to fail and receive damge 
                # debug_log "We failed the check, normal Sanity loss";
                # debug_log to_mana;
                return;
              end;
                sub sanityDamage 1;
                set to_mana sanityDamage;
                # debug_log "We passed the check so we reduce Sanity loss by 1";
                # debug_log to_mana;
                return;
              end;
              if eq unitBravery 110; #Has a 75% chance to reduce Sanity damage by 1, additional roll for 25%
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "apply chance for roll 1:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                # debug_log "We failed the check, normal Sanity loss";
                # debug_log to_mana;
                return;
              end;
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "first roll succeded, apply chance for roll 2:";
              # debug_log applyChance;
              if gt 75 applyChance; # 75% chance to fail and receive damge 
                sub sanityDamage 1;
                set to_mana sanityDamage;
                # debug_log "We passed the first check so we reduce Sanity loss by 1, failed second check";
                # debug_log to_mana;
                return;
              end;
                sub sanityDamage 2;
                set to_mana sanityDamage;
                # debug_log "We passed BOTH checks so we reduce Sanity loss by 2";
                # debug_log to_mana;
                return;
              end;
              if eq unitBravery 120; #Has a 75% chance to reduce Sanity damage by 1, additional roll for 50%
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "apply chance is:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                # debug_log "We failed the check, normal Sanity loss";
                # debug_log to_mana;
                return;
              end;
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "first roll succeded, apply chance for roll 2:";
              # debug_log applyChance;
              if gt 50 applyChance; # 50% chance to fail and receive damge 
                sub sanityDamage 1;
                set to_mana sanityDamage;
                # debug_log "We passed the first check so we reduce Sanity loss by 1, failed second check";
                # debug_log to_mana;
                return;
              end;
                sub sanityDamage 2;
                set to_mana sanityDamage;
                # debug_log "We passed BOTH checks so we reduce Sanity loss by 2";
                # debug_log to_mana;
                return;
              end;
              if eq unitBravery 130; #Has a 75% chance to reduce Sanity damage by 1, additonal roll for 75%
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "apply chance is:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                # debug_log "We failed the check, normal Sanity loss";
                # debug_log to_mana;
                return;
              end;
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "first roll succeded, apply chance for roll 2:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                sub sanityDamage 1;
                set to_mana sanityDamage;
                # debug_log "We passed the first check so we reduce Sanity loss by 1, failed second check";
                # debug_log to_mana;
                return;
              end;
                sub sanityDamage 2;
                set to_mana sanityDamage;
                # debug_log "We passed BOTH checks so we reduce Sanity loss by 2";
                # debug_log to_mana;
                return;
              end;
              if eq unitBravery 140; #Has a 75% chance to reduce Sanity damage by 1,  has 2 additional rolls: 1 for 75% and one for 25%
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "apply chance is:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                # debug_log "We failed the check, normal Sanity loss";
                # debug_log to_mana;
                return;
              end;
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "first roll succeded, apply chance for roll 2:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                sub sanityDamage 1;
                set to_mana sanityDamage;
                # debug_log "We passed the first check so we reduce Sanity loss by 1, failed second check";
                # debug_log to_mana;
                return;
              end;
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "second roll succeded, apply chance for roll 3:";
              # debug_log applyChance;
              if gt 75 applyChance; # 75% chance to fail and receive damge 
                sub sanityDamage 2;
                set to_mana sanityDamage;
                # debug_log "We passed the first check and second check so we reduce Sanity loss by 2, failed third check";
                # debug_log to_mana;
                return;
              end;
                sub sanityDamage 3;
                set to_mana sanityDamage;
                # debug_log "We passed ALL 3 checks so we reduce Sanity loss by 3";
                # debug_log to_mana;
                return;
              end;
              if eq unitBravery 150; #Has a 75% chance to reduce Sanity damage by 1, has 2 additionall rolls: 1 for 75% and another one for 50%
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "apply chance is:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                # debug_log "We failed the check, normal Sanity loss";
                # debug_log to_mana;
                return;
              end;
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "first roll succeded, apply chance for roll 2:";
              # debug_log applyChance;
              if gt 25 applyChance; # 25% chance to fail and receive damge 
                sub sanityDamage 1;
                set to_mana sanityDamage;
                # debug_log "We passed the first check so we reduce Sanity loss by 1, failed second check";
                # debug_log to_mana;
                return;
              end;
              battle_game.randomRange applyChance 1 100; #calculate random chance for debuff apply
              # debug_log "second roll succeded, apply chance for roll 3:";
              # debug_log applyChance;
              if gt 50 applyChance; # 50% chance to fail and receive damge 
                sub sanityDamage 2;
                set to_mana sanityDamage;
                # debug_log "We passed the first check and second check so we reduce Sanity loss by 2, failed third check";
                # debug_log to_mana;
                return;
              end;
                sub sanityDamage 3;
                set to_mana sanityDamage;
                # debug_log "We passed ALL 3 checks so we reduce Sanity loss by 3";
                # debug_log to_mana;
                return;
              end;
              return;
            end;
            return;
          end;

          return;

    createUnit:
        #*** Sets the frequency and offset for periodic unit recolors for buffs and debuffs ***
      - offset: 1
        code: |
          var int recolorPeriod;
          var int desync;

          set recolorPeriod 32; # units flash every 32 frames
          unit.getId desync;
          offsetmod desync 11 0 recolorPeriod; # creates a desynchronization between unit flashes
          unit.setTag Tag.UNIT_RECOLOR_DESYNC desync;

          return;



      - offset: 2
        code: |
          # Set energy shields on unit armor at beginning of the battle
          
          var ptr RuleArmor armorRuleset;
          var int shieldCapacity;
          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldCapacity Tag.ARMOR_ENERGY_SHIELD_CAPACITY;
          
          if eq shieldCapacity 0;
            return;
          end;
          
          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldCapacity;
          
          return;

      - offset: 3
        #*** Handcuffs stuff ***
        code: |
          var ptr RuleArmor UnitRuleset;
          var int HandcuffProtection 0;
          
          unit.getRuleArmor UnitRuleset;
          UnitRuleset.getTag HandcuffProtection Tag.HANDCUFF_PROTECTION;
          
          if gt HandcuffProtection 0;
            unit.setTag Tag.UNIT_HANDCUFF_PROTECTION HandcuffProtection; 
            # debug_log "createUnit: unit.setTag.UNIT_HANDCUFF_PROTECTION: " HandcuffProtection;
          end;
          return;

      - offset: 4 #Mechanical Repair Script 
        code: |
          var int mechanicalTag;
          var int unitHealthMax;
          var ptr RuleArmor armorRuleset;
          
          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag mechanicalTag Tag.ARMOR_IS_MECHANICAL;

          if or eq mechanicalTag 1;
            unit.setTag Tag.UNIT_IS_MECHANICAL 1;
            # debug_log "Unit was robotic/mechanical and suitable for repair!";
            unit.getHealthMax unitHealthMax;
            # debug_log "Unit maxhealth BEFORE division is: ";
            # debug_log unitHealthMax;
            div unitHealthMax 3;
            # debug_log "Unit maxhealth AFTER division is: ";
            # debug_log unitHealthMax;
            unit.setTag Tag.UNIT_REPAIR_LIMIT unitHealthMax;
          end;
          return;
    healUnit:
      - offset: 1
        #*** Handcuffs stuff ***
        code: |
          var int HandcuffPower 0;
          var int HandcuffProtection 0;
          var int HandcuffLevel 0;
          var int CurrStun 0;
          var int NewStun 0;
          var int CurrEnergy 0;
          var int CurrTU 0;
          
          item.getTag HandcuffPower Tag.ITEM_HANDCUFF_POWER;
          target.getTag HandcuffProtection Tag.UNIT_HANDCUFF_PROTECTION;
          
          # debug_log "healUnit: handcuffing ITEM_HANDCUFF_POWER: " HandcuffPower " on UNIT_HANDCUFF_PROTECTION: " HandcuffProtection;
          
          if gt HandcuffPower 0;
            if gt HandcuffPower HandcuffProtection;            
              target.getTag HandcuffLevel Tag.UNIT_HANDCUFF_LEVEL;
              target.getStunMax NewStun;
              if gt NewStun 200;
                set NewStun 200;
              end;
              target.getStun CurrStun;
              if eq HandcuffLevel 0;
                target.setTag Tag.VIRTUAL_STUN_LEVEL CurrStun;
                target.setStun NewStun;
              end;
            
              add HandcuffLevel HandcuffPower;
              target.setTag Tag.UNIT_HANDCUFF_LEVEL HandcuffLevel;
            
              # debug_log "healUnit: ITEM_HANDCUFF_POWER (" HandcuffPower ") > UNIT_HANDCUFF_PROTECTION (" HandcuffProtection ") then target.setTag.UNIT_HANDCUFF_LEVEL: " HandcuffLevel ", target.setTag.VIRTUAL_STUN_LEVEL: " CurrStun ", target.setStun: " NewStun;
            
            else le HandcuffPower HandcuffProtection;
              actor.getEnergy CurrEnergy;
              actor.getTimeUnits CurrTU;
              add CurrEnergy 10;
              add CurrTU 40;
              item.setStimulantQuantity 1;
              actor.setTimeUnits CurrTU;
              actor.setEnergy CurrEnergy;
            
              # debug_log "healUnit: ITEM_HANDCUFF_POWER (" HandcuffPower ") <= UNIT_HANDCUFF_PROTECTION (" HandcuffProtection ") then item.setStimulantQuantity: 1, actor.setTimeUnits: " CurrTU ", actor.setEnergy: " CurrEnergy;
            end;
          end;
          
          return;

      - offset: 50
        #*** Stat boosting ***
        code: |
          var int temp;

          item.getTag temp Tag.WM_IS_WACKY;

          if neq temp 0;
            # debug_log "healUnit: applying wacky medikit, skip normal effects completely";
            set medikit_action_type 0;

            target.getTimeUnits temp;
            add temp 55;
            target.setTimeUnits temp;

            target.getEnergy temp;
            add temp 60;
            target.setEnergy temp;

            return;
          end;

          # debug_log "healUnit: not wacky...";
          return;

    createItem:
      - offset: 1
        code: |
          # Set energy shields on items at beginning of the battle

          var ptr RuleItem itemRuleset;
          var int shieldCapacity;
          var int temp;

          item.getRuleItem itemRuleset;
          itemRuleset.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;
          itemRuleset.getTag temp Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          # Only set shield values at beginning of battlescape for shields that don't need priming
          if and neq shieldCapacity 0 eq temp 0;
            item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;
          end;

          return;

      - offset: 2
        #*** Handcuffs stuff ***
        code: |
          var ptr RuleItem ItemRuleset;
          var int HandcuffPower 0;
          
          item.getRuleItem ItemRuleset;
          ItemRuleset.getTag HandcuffPower Tag.HANDCUFF_POWER;
          
          if gt HandcuffPower 0;
            item.setTag Tag.ITEM_HANDCUFF_POWER HandcuffPower; 
            # debug_log "createItem: item.setTag.ITEM_HANDCUFF_POWER: " HandcuffPower;
          end;
          return;      

    newTurnUnit:
      - offset: 1
        code: |
          # Clear recolor tags
          unit.setTag Tag.UNIT_RECOLOR_START_FRAME 0;
          unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 0;
          unit.setTag Tag.UNIT_RECOLOR_COLOR 0;

          # Clear all unit resist types and minimums so resistance items can set again
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_2 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_3 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_4 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_5 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_6 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_7 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_8 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_9 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_10 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_11 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_12 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_13 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_14 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_15 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_16 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_17 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_18 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_19 0;
          unit.setTag Tag.UNIT_RESIST_ITEM_SLOT_20 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_0 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_1 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_2 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_3 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_4 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_5 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_6 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_7 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_8 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_9 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_10 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_11 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_12 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_13 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_14 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_15 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_16 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_17 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_18 0;
          unit.setTag Tag.UNIT_RESIST_TYPE_19 0;

          return;

      - offset: 2
        code: |
          # Handle energy shield on armor regeneration/degeneration every turn

          var ptr RuleArmor armorRuleset;
          var int shieldCapacity;
          var int shieldPerTurn;
          var int shieldHp;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag shieldCapacity Tag.ARMOR_ENERGY_SHIELD_CAPACITY;
          armorRuleset.getTag shieldPerTurn Tag.ARMOR_ENERGY_SHIELD_PER_TURN;

          if eq shieldPerTurn 0;
            return;
          end;

          unit.getTag shieldHp Tag.UNIT_ENERGY_SHIELD_HP;
          add shieldHp shieldPerTurn;
          limit shieldHp 0 shieldCapacity;
          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP shieldHp;

          return;

      - offset: 3 #Rotting Script
        code: |
          var ptr RuleArmor armorRuleset;
          var int currHealth;
          var int rottingDamage;
          var int rottingMin;
          var int rottingMax;

          unit.getRuleArmor armorRuleset;
          armorRuleset.getTag rottingMin Tag.FTAG_ROTTINGMIN; #get stats from a unit
          armorRuleset.getTag rottingMax Tag.FTAG_ROTTINGMAX;

          # Make sure this doesn't run an extra time when civilians have a turn
          #if eq side 2;
          #  return;
          #end;

          battle_game.randomRange rottingDamage rottingMin rottingMax; #calculate rotting
          unit.Stats.getHealth currHealth; #apply rotting
          sub currHealth rottingDamage;
          unit.Stats.setHealth currHealth;

           return;

      - offset: 4 #Flashbang ongoing check script
        code: |
          var int currTurn;
          var int endTurn;
          var int dazeTag;
          var int originalTimeUnits;
          var int originalReactions;
          var int originalFiring;
          var int originalThrowing;
          var int originalMelee;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          unit.getTag dazeTag Tag.FTAG_ISDAZED;
          unit.getTag endTurn Tag.FTAG_DAZE_ENDTURN;
          unit.getTag originalTimeUnits Tag.FTAG_DAZE_ORIGINAL_TIMEUNITS;
          unit.getTag originalReactions Tag.FTAG_DAZE_ORIGINAL_REACTIONS;
          unit.getTag originalFiring Tag.FTAG_DAZE_ORIGINAL_FIRING;
          unit.getTag originalThrowing Tag.FTAG_DAZE_ORIGINAL_THROWING;
          unit.getTag originalMelee Tag.FTAG_DAZE_ORIGINAL_MELEE;

          battle_game.getTurn currTurn;

          if eq dazeTag 69;
            if eq currTurn endTurn;
              unit.Stats.setTimeUnits originalTimeUnits; #revent debuff
              unit.Stats.setReactions originalReactions; 
              unit.Stats.setFiring originalFiring; 
              unit.Stats.setThrowing originalThrowing; 
              unit.Stats.setMelee originalMelee; 
              unit.setTag Tag.FTAG_ISDAZED 0; #cancel tag
              battle_game.flashMessage "STR_TARGET_IS_NOT_DAZED";
            end;
          end;

          return;

      - offset: 5
        #*** Handcuffs stuff ***
        code: |
          var int HandcuffLevel 0;
          var int CurrStrength 0;
          var int HandcuffPower 0;
          var int NewStun 0;
          var int CurrStun 0;
          var int PrevStun 0;
          var int StrengthLevel 0;
          var int RandomValue 0;
          var int CurrTurnSide 0;
          var int UnitFaction 0;
          var int UnitStatHealth 0;
          var int UnitHealth 0;
          
          unit.getTag HandcuffLevel Tag.UNIT_HANDCUFF_LEVEL;
                    
          if gt HandcuffLevel 0;
            battle_game.getTurnSide CurrTurnSide;
            unit.getFaction UnitFaction;
            
            if eq CurrTurnSide UnitFaction;
              # debug_log "newTurnUnit: if CurrTurnSide (" CurrTurnSide ") = UnitFaction (" UnitFaction ") then ...";
              
              unit.Stats.getStrength CurrStrength;
              set StrengthLevel CurrStrength;
              sub StrengthLevel HandcuffLevel;
              if lt StrengthLevel 0;
                clear StrengthLevel;
              end;
              if gt StrengthLevel 90;
                set StrengthLevel 90;
              end;
              
              battle_game.randomRange RandomValue 1 100;
              
              # debug_log "newTurnUnit: unit.Stats.getStrength: " CurrStrength ", battle_game.randomRange: " RandomValue ", StrengthLevel: " StrengthLevel;
              
              unit.getTag PrevStun Tag.VIRTUAL_STUN_LEVEL;
              
              if gt PrevStun 0;
                set RandomValue 100;
                # debug_log "newTurnUnit: if PrevStun(" PrevStun ") > 0 then set RandomValue = " RandomValue;
              end;
              
              if le RandomValue StrengthLevel;
                if lt PrevStun 0;
                  clear PrevStun;
                end;
                unit.setStun PrevStun;
                unit.setTag Tag.UNIT_HANDCUFF_LEVEL 0;
                unit.setTag Tag.VIRTUAL_STUN_LEVEL 0;
                # debug_log "newTurnUnit: if RandomValue (" RandomValue ") <= StrengthLevel (" StrengthLevel ") then unit.setStun: " PrevStun ", remove tags";
                
              else gt RandomValue StrengthLevel;
                unit.getStun CurrStun;
                unit.getStunMax NewStun;
                unit.Stats.getHealth UnitStatHealth;
                unit.getHealth UnitHealth;
                
                muldiv NewStun UnitHealth UnitStatHealth;
                # debug_log "newTurnUnit: unit.Stats.getHealth = " UnitStatHealth ", unit.getHealth = " UnitHealth ", NewStun = " NewStun;
                
                sub CurrStun NewStun;
                add PrevStun CurrStun;
                if lt PrevStun 0;
                  set PrevStun 0;
                end;
                unit.setTag Tag.VIRTUAL_STUN_LEVEL PrevStun;
                unit.setStun NewStun;
                # debug_log "newTurnUnit: if RandomValue (" RandomValue ") > StrengthLevel (" StrengthLevel ") then unit.setTag.VIRTUAL_STUN_LEVEL: " PrevStun ",   unit.setStun: " NewStun;
              end;
            end;            
          end;
          return;

    newTurnItem:
      - offset: 2
        code: |
          # Handle energy shield on items regeneration/degeneration every turn

          var ptr RuleItem shieldRule;
          var int shieldCapacity;
          var int shieldTimer;
          var int shieldIsPrimed;
          var int shieldPerTurn;
          var int shieldHp;
          var int temp;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          # Recharge/decay handling for shield items
          item.getRuleItem shieldRule;
          shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return;
          end;

          # Check if this is prime-able type, handle if it is
          shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          if neq temp 0;
            item.getFuseTimer shieldTimer;

            if neq shieldTimer -1;
              # Make sure it's primed, if not, do so now
              item.getTag shieldIsPrimed Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

              if eq shieldIsPrimed 0;
                item.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;
              end;

              shieldRule.getTag shieldPerTurn Tag.ITEM_ENERGY_SHIELD_PER_TURN;
              item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

              # Recharge/decay shield, respecting capacity and 0
              add shieldHp shieldPerTurn;
              limit shieldHp 0 shieldCapacity;
              item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldHp;
            end;
          else;
            # Handling here for shields that don't need priming
            shieldRule.getTag shieldPerTurn Tag.ITEM_ENERGY_SHIELD_PER_TURN;
            item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

            # Recharge/decay shield, respecting capacity and 0
            add shieldHp shieldPerTurn;
            limit shieldHp 0 shieldCapacity;
            item.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldHp;
          end;

          return;

      - offset: 3
        code: |
          var ptre BattleUnit itemOwner;
          var ptr RuleItem itemRuleset;
          var int itemResistSlotIndex;
          var int itemResistMinimum;
          var int itemResistCoeff;
          var int currentResistance;
          var int oneMinusResistance;
          var int temp;

          item.getOwner itemOwner;

          # If no owner, skip script
          if eq itemOwner null;
            return;
          end;

          # Check the item's slot index; if it's already set on this unit, don't count this item
          item.getRuleItem itemRuleset;
          itemRuleset.getTag itemResistSlotIndex Tag.ITEM_RESIST_SLOT_INDEX;

          if eq itemResistSlotIndex 1;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_1;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_1 1;
            end;

          else eq itemResistSlotIndex 2;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_2;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_2 1;
            end;
          else eq itemResistSlotIndex 3;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_3;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_3 1;
            end;
          else eq itemResistSlotIndex 4;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_4;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_4 1;
            end;
          else eq itemResistSlotIndex 5;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_5;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_5 1;
            end;
          else eq itemResistSlotIndex 6;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_6;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_6 1;
            end;
          else eq itemResistSlotIndex 7;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_7;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_7 1;
            end;
          else eq itemResistSlotIndex 8;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_8;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_8 1;
            end;
          else eq itemResistSlotIndex 9;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_9;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_9 1;
            end;
          else eq itemResistSlotIndex 10;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_10;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_10 1;
            end;
          else eq itemResistSlotIndex 11;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_11;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_11 1;
            end;
          else eq itemResistSlotIndex 12;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_12;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_12 1;
            end;
          else eq itemResistSlotIndex 13;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_13;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_13 1;
            end;
          else eq itemResistSlotIndex 14;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_14;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_14 1;
            end;
          else eq itemResistSlotIndex 15;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_15;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_15 1;
            end;
          else eq itemResistSlotIndex 16;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_16;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_16 1;
            end;
          else eq itemResistSlotIndex 17;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_17;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_17 1;
            end;
          else eq itemResistSlotIndex 18;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_18;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_18 1;
            end;
          else eq itemResistSlotIndex 19;
            itemOwner.getTag temp Tag.UNIT_RESIST_ITEM_SLOT_19;

            if eq temp 1;
              return;
            else;
              itemOwner.setTag Tag.UNIT_RESIST_ITEM_SLOT_19 1;
            end;
          end;

          # CURRENT RES = CURRENT RES - ((1 - ITEM RES) * (CURRENT RES - ITEM ZERO POINT))

          # Check for minimum resist on item, if there is none, skip resist type
          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_0;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_0;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_0;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 0;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_0 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_1;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_1;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_1;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 1;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_1 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_2;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_2;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_2;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 2;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_2 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_3;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_3;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_3;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 3;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_3 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_4;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_4;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_4;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 4;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_4 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_5;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_5;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_5;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 5;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_5 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_6;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_6;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_6;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 6;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_6 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_7;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_7;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_7;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 7;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_7 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_8;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_8;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_8;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 8;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_8 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_9;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_9;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_9;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 9;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_9 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_10;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_10;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_10;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 10;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_10 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_11;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_11;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_11;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 11;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_11 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_12;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_12;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_12;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 12;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_12 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_13;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_13;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_13;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 13;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_13 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_14;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_14;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_14;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 14;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_14 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_15;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_15;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_15;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 15;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_15 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_16;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_16;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_16;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 16;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_16 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_17;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_17;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_17;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 17;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_17 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_18;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_18;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_18;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 18;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_18 currentResistance;
            end;
          end;

          itemRuleset.getTag itemResistMinimum Tag.ITEM_MINIMUM_RESIST_TYPE_19;

          if neq itemResistMinimum 0;
            itemRuleset.getTag itemResistCoeff Tag.ITEM_RESIST_TYPE_19;
            itemOwner.getTag temp Tag.UNIT_RESIST_TYPE_19;

            # If current resist is equal to 0, get resistance from armor to start
            if eq temp 0;
              set temp 100;
              itemOwner.reduceByResistance temp 19;
            end;

            # Only set resistance if better than current tag
            if and neq temp 0 lt itemResistMinimum temp;
              set currentResistance temp;
              set oneMinusResistance 100;
              sub temp itemResistMinimum;
              sub oneMinusResistance itemResistCoeff;
              muldiv temp oneMinusResistance 100;
              sub currentResistance temp;
              itemOwner.setTag Tag.UNIT_RESIST_TYPE_19 currentResistance;
            end;
          end;

          return;

      - offset: 4
        code: |
          # Items that change stun, energy, and morale on a per-(half)-turn basis
          var ptre BattleUnit unit;
          var ptr RuleItem itemRuleset;
          var int changePerTurn;
          var int currentValue;
          var int changedValue;
          var int maxValue;

          # Make sure this doesn't run an extra time when civilians have a turn
          if eq side 2;
            return;
          end;

          item.getOwner unit;

          if eq unit null;

            return;

          end;

          item.getRuleItem itemRuleset;

          itemRuleset.getTag changePerTurn Tag.ITEM_STUN_PER_TURN;
          unit.getStun currentValue;
          unit.getStunMax maxValue;
          set changedValue currentValue;
          add changedValue changePerTurn;
          limit changedValue 0 maxValue;
          unit.setStun changedValue;

          itemRuleset.getTag changePerTurn Tag.ITEM_ENERGY_PER_TURN;
          unit.getEnergy currentValue;
          unit.getEnergyMax maxValue;
          set changedValue currentValue;
          add changedValue changePerTurn;
          limit changedValue 0 maxValue;
          unit.setEnergy changedValue;

          itemRuleset.getTag changePerTurn Tag.ITEM_MORALE_PER_TURN;
          unit.getMorale currentValue;
          unit.getMoraleMax maxValue;
          set changedValue currentValue;
          add changedValue changePerTurn;
          limit changedValue 0 maxValue;
          unit.setMorale changedValue;

          return;

    hitUnit:
      - offset: 0.1 #Anti-psiker weapon
        code: |
          var ptr RuleItem itemRuleset;
          var int addPower;
          var int psiStrength;

          damaging_item.getRuleItem itemRuleset; #get stats from item
          itemRuleset.getTag addPower Tag.FTAG_TOPSIKER_ADD_POWER;

          if neq addPower 0;
            unit.Stats.getPsiStrength psiStrength;
            mul addPower psiStrength;
            
            div addPower 100;
            #debug_log 2 addPower; #for good
            add power addPower;
          end;

          return power part side;

      - offset: 1
        code: |
          # Handle item energy shields on hit

          var ptre BattleItem shieldItem;
          var ptr RuleItem shieldRule;
          var int shieldCapacity;
          var int shieldNeedsPriming;
          var int shieldTimer;
          var int shieldType;
          var int shieldResistCoeff;
          var int shieldHp;
          var int temp;

          # Script to handle item energy shields on hit
          # Check for item in left hand
          unit.getLeftHandWeapon shieldItem;

          if neq shieldItem null;
            # Check to see if the item has a shield capacity tag
            shieldItem.getRuleItem shieldRule;
            shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

            if neq shieldCapacity 0;

              # Check if we need to handle prime-able shields
              shieldItem.getFuseTimer shieldTimer;
              shieldRule.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

              set temp 0; # Ensure this is equal to 0 for the check whether the shield is used to reduce damage

              if and neq shieldTimer -1 neq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

                if eq temp 0; # If we just primed and haven't been hit yet, need to set shield HP
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;

                  set temp 1; # Tells that shield is primed and ready for use
                end;
              end;

              # If shield doesn't need priming, it's ready to go. Otherwise, make sure temp was set by the priming action
              if or eq shieldNeedsPriming 0 neq temp 0; 

                shieldRule.getTag shieldType Tag.ITEM_ENERGY_SHIELD_TYPE;

                if or eq shieldType 0 eq shieldType 1; # Default and shield type 1
                  # Check which damage type and set shield's 'resistance'
                  # If it's special, choking, heat, or cold, just skip the rest
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;

                  # resistances
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 2;
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 3;
                  if or eq damaging_type 0 eq damaging_type 8 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else or eq damaging_type 15 eq damaging_type 16 eq damaging_type 17;
                    return power part side;
                  else eq damaging_type 1; # AP
                    set shieldResistCoeff 75;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 50;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 50;
                  else eq damaging_type 13; # EMP
                    set shieldResistCoeff 200;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                end;

                # Get the item's HP value and reduce damage by it
                shieldItem.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

                # Modify shield hp value by resistance to get effective HP
                muldiv shieldHp 100 shieldResistCoeff;
                set temp shieldHp;

                sub temp power; # get shield value leftover after hit
                sub power shieldHp; # reduce hit by hp

                # Return shield to pre-resistance units
                muldiv temp shieldResistCoeff 100;

                # Apply limits to make sure no negative power/HP
                limit_lower power 0;
                limit_lower temp 0;

                # Set the shield's new HP value
                shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP temp;

                # Make the unit flash a color to denote shield was hit
                if and gt temp 0 eq power 0; # But only if shield is left over
                  battle_game.getAnimFrame temp;
                  unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
                  unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

                  shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_FLASH_COLOR;
                  if eq temp 0;
                    set temp COLOR_X1_BLUE1; # Default color is bright blue
                  end;
                  unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
                end;
              end;
            end;
          end;

          # Now do it for a right hand shield
          unit.getRightHandWeapon shieldItem;

          if neq shieldItem null;
            # Check to see if the item has a shield capacity tag
            shieldItem.getRuleItem shieldRule;
            shieldRule.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

            if neq shieldCapacity 0;

              # Check if we need to handle prime-able shields
              shieldItem.getFuseTimer shieldTimer;
              shieldRule.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

              set temp 0; # Ensure this is equal to 0 for the check whether the shield is used to reduce damage

              if and neq shieldTimer -1 neq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

                if eq temp 0; # If we just primed and haven't been hit yet, need to set shield HP
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_IS_PRIMED 1;
                  shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP shieldCapacity;

                  set temp 1; # Tells that shield is primed and ready for use
                end;
              end;

              # If shield doesn't need priming, it's ready to go. Otherwise, make sure temp was set by the priming action
              if or eq shieldNeedsPriming 0 neq temp 0; 

                shieldRule.getTag shieldType Tag.ITEM_ENERGY_SHIELD_TYPE;

                if or eq shieldType 0 eq shieldType 1; # Default and shield type 1
                  # Check which damage type and set shield's 'resistance'
                  # If it's special, choking, heat, or cold, just skip the rest
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;

                  # resistances
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 2;
                  if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 35;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 60;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                else eq shieldType 3;
                  if or eq damaging_type 0 eq damaging_type 8 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
                    return power part side;
                  else or eq damaging_type 15 eq damaging_type 16 eq damaging_type 17;
                    return power part side;
                  else eq damaging_type 1; # AP
                    set shieldResistCoeff 75;
                  else eq damaging_type 4; # Laser
                    set shieldResistCoeff 50;
                  else eq damaging_type 5; # Plasma
                    set shieldResistCoeff 50;
                  else eq damaging_type 13; # EMP
                    set shieldResistCoeff 200;
                  else; # All other damage types
                    set shieldResistCoeff 100;
                  end;

                end;

                # Get the item's HP value and reduce damage by it
                shieldItem.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;

                # Modify shield hp value by resistance to get effective HP
                muldiv shieldHp 100 shieldResistCoeff;
                set temp shieldHp;

                sub temp power; # get shield value leftover after hit
                sub power shieldHp; # reduce hit by hp

                # Return shield to pre-resistance units
                muldiv temp shieldResistCoeff 100;

                # Apply limits to make sure no negative power/HP
                limit_lower power 0;
                limit_lower temp 0;

                # Set the shield's new HP value
                shieldItem.setTag Tag.ITEM_ENERGY_SHIELD_HP temp;

                # Make the unit flash a color to denote shield was hit
                if and gt temp 0 eq power 0; # But only if shield is left over
                  battle_game.getAnimFrame temp;
                  unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
                  unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

                  shieldRule.getTag temp Tag.ITEM_ENERGY_SHIELD_FLASH_COLOR;
                  if eq temp 0;
                    set temp COLOR_X1_BLUE1; # Default color is bright blue
                  end;
                  unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
                end;
              end;
            end;
          end;

          # return modified power
          return power part side;

      - offset: 2
        code: |
          # Handle energy shields on armor on hit

          var ptr RuleArmor armorRuleset;
          var int shieldHp;
          var int shieldType;
          var int shieldResistCoeff;
          var int temp;

          unit.getTag shieldHp Tag.UNIT_ENERGY_SHIELD_HP;

          if eq shieldHp 0;
            return power part side;
          end;

          unit.getRuleArmor armorRuleset;

          armorRuleset.getTag shieldType Tag.ARMOR_ENERGY_SHIELD_TYPE;

          if or eq shieldType 0; # Default; Tzeentch
            # Check which damage type and set shield's 'resistance'
            # If it's special, choking, heat, or cold, just skip the rest
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 50;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 50;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 50;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 175;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 175;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 66;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 33;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 33;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 1; # Shield type 1 - Slaanesh
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 175;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 175;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 175;
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 33;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 50;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 50;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 66;
            else eq damaging_type 11; # Electric
              set shieldResistCoeff 66;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 2; # Shield type 2 - Nurgle
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 175;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 6; # Stun
              set shieldResistCoeff 33;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 8; # Acid
              set shieldResistCoeff 33;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 33;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 50;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 50;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          else eq shieldType 3; # Shield type 3 - Khorne
            if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 14;
              return power part side;

            # resistances
            else eq damaging_type 1; # AP
              set shieldResistCoeff 33;
            else eq damaging_type 2; # Incendiary
              set shieldResistCoeff 33;
            else eq damaging_type 3; # Hi-Ex
              set shieldResistCoeff 33;
            else eq damaging_type 4; # Laser
              set shieldResistCoeff 50;
            else eq damaging_type 5; # Plasma
              set shieldResistCoeff 125;
            else eq damaging_type 7; # Melee
              set shieldResistCoeff 125;
            else eq damaging_type 10; # EMP
              set shieldResistCoeff 150;
            else eq damaging_type 12; # Psi
              set shieldResistCoeff 175;
            else eq damaging_type 13; # Warp
              set shieldResistCoeff 175;
            else; # All other damage types
              set shieldResistCoeff 100;
            end;

          end;

          # Get the item's HP value and reduce damage by it
          # Modify shield hp value by resistance to get effective HP
          muldiv shieldHp 100 shieldResistCoeff;
          set temp shieldHp;

          sub temp power; # get shield value leftover after hit
          sub power shieldHp; # reduce hit by hp

          # Return shield to pre-resistance units
          muldiv temp shieldResistCoeff 100;

          # Apply limits to make sure no negative power/HP
          limit_lower power 0;
          limit_lower temp 0;

          unit.setTag Tag.UNIT_ENERGY_SHIELD_HP temp;

          # Make the unit flash a color to denote shield was hit
          if and gt temp 0 eq power 0; # But only if shield is left over
            battle_game.getAnimFrame temp;
            unit.setTag Tag.UNIT_RECOLOR_START_FRAME temp;
            unit.setTag Tag.UNIT_RECOLOR_FRAME_LENGTH 3;

            armorRuleset.getTag temp Tag.ARMOR_ENERGY_SHIELD_FLASH_COLOR;
            if eq temp 0;
              set temp COLOR_X1_BLUE1; # Default color is bright blue
            end;
            unit.setTag Tag.UNIT_RECOLOR_COLOR temp;
          end;

          return power part side;

      - offset: 3
        code: |
          var ptr BattleItem shieldItem;
          var ptr RuleItem damagingRuleset;
          var ptr RuleItem shieldRuleset;
          var int shieldArmor;
          var int shieldResistCoeff;
          var int shieldMeleeDodge;
          var int shieldReactionsDodge;
          var int unitMelee;
          var int unitReactions;
          var int temp;

          # Check for shield in left hand first, then right.  If no shield, skip the script
          unit.getLeftHandWeapon shieldItem;
          shieldItem.getRuleItem shieldRuleset;
          shieldRuleset.getTag shieldArmor Tag.PHYSICAL_SHIELD_ARMOR;
          shieldRuleset.getTag shieldMeleeDodge Tag.ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT;
          shieldRuleset.getTag shieldReactionsDodge Tag.ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT;

          if eq shieldArmor 0;
            unit.getRightHandWeapon shieldItem;
            shieldItem.getRuleItem shieldRuleset;
            shieldRuleset.getTag shieldArmor Tag.PHYSICAL_SHIELD_ARMOR;
            shieldRuleset.getTag shieldMeleeDodge Tag.ITEM_SHIELD_BLOCK_MELEE_COEFFICIENT;
            shieldRuleset.getTag shieldReactionsDodge Tag.ITEM_SHIELD_BLOCK_REACTIONS_COEFFICIENT;
            if eq shieldArmor 0;
              return power part side;
            end;
          end;

          # Check which damage type and set shield's 'resistance'
          # If it's special, choking, heat, or cold, just skip the rest
          if or eq damaging_type 0 eq damaging_type 9 eq damaging_type 10 eq damaging_type 11;
            return power part side;
          end;

          # Check to see if the shield blocks all damage from a melee hit, like melee dodge
          damaging_item.getRuleItem damagingRuleset;
          damagingRuleset.getTag temp Tag.ITEM_IS_MELEE;
          if or neq 0 temp eq battle_action BA_HIT;
            # Get the stats for melee dodge
            unit.Stats.getMelee unitMelee;
            unit.Stats.getReactions unitReactions;
            muldiv shieldMeleeDodge unitMelee 100;
            muldiv shieldReactionsDodge unitReactions 100;
            add shieldMeleeDodge shieldReactionsDodge;

            # Modify by where the unit was hit
            if or eq side SIDE_LEFT eq side SIDE_RIGHT;
              div shieldMeleeDodge 2;
            else or eq side SIDE_REAR eq side SIDE_UNDER;
              div shieldMeleeDodge 4;
            end;

            battle_game.randomChance temp;
            if lt temp shieldMeleeDodge;
              set power 0;
              return power part side;
            end;
          end;
  
          # Default resistances for all physical shields
          if eq damaging_type 3; # Concussive
            set shieldResistCoeff 90;
          else eq damaging_type 6; # Daze
            set shieldResistCoeff 80;
          else eq damaging_type 7; # Cutting
            set shieldResistCoeff 90;
          else eq damaging_type 7; # Chem
            set shieldResistCoeff 90;
          else; # All other damage types
            set shieldResistCoeff 100;
          end;

          # Calculate the shield's effectiveness and subtract it from the damage
          muldiv shieldArmor 100 shieldResistCoeff;

          if or eq side SIDE_LEFT eq side SIDE_RIGHT;
            div shieldArmor 2;
          else eq side SIDE_UNDER;
            div shieldArmor 4;
          else eq side SIDE_REAR;
            set shieldArmor 0;
          end;

          sub power shieldArmor;
          limit_lower power 0;

          return power part side;

      - offset: 4
        code: |
          var int unitResistCoeff;
          var int armorResistCoeff;
          var int temp;

          if eq damaging_type 0;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_0;
          else eq damaging_type 1;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_1;
          else eq damaging_type 2;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_2;
          else eq damaging_type 3;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_3;
          else eq damaging_type 4;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_4;
          else eq damaging_type 5;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_5;
          else eq damaging_type 6;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_6;
          else eq damaging_type 7;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_7;
          else eq damaging_type 8;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_8;
          else eq damaging_type 9;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_9;
          else eq damaging_type 10;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_10;
          else eq damaging_type 11;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_11;
          else eq damaging_type 12;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_12;
          else eq damaging_type 13;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_13;
          else eq damaging_type 14;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_14;
          else eq damaging_type 15;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_15;
          else eq damaging_type 16;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_16;
          else eq damaging_type 17;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_17;
          else eq damaging_type 18;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_18;
          else eq damaging_type 19;
            unit.getTag unitResistCoeff Tag.UNIT_RESIST_TYPE_19;
          end;

          # either no tag exists or armor has resistance of 0 (no damage anyways)
          if eq unitResistCoeff 0;
            return power part side;
          end;

          set armorResistCoeff 100;
          unit.reduceByResistance armorResistCoeff damaging_type;

          # Since unitResistCoeff already includes armor value, need to divide power by resist so it isn't included twice in calculation
          # final power = power * unit resistance tag (which is equivalent "units" to item resistance * armor resistance) / armor resistance
          muldiv power unitResistCoeff armorResistCoeff;

          return power part side;

      - offset: 1 #Mechanical Repair Script
        code: |
          var int mechanicalTag;
          var int repairHPLimit;
          var int repairHPCurrent;
          var int repairKitPower;
          var int repairKitTag;
          var int repairValue;
          var int currHealth;
          var int maxHealth;
          var int healthValue;

          set repairValue 0;
          set healthValue 0;
          set repairKitPower 0;

          unit.getTag mechanicalTag Tag.UNIT_IS_MECHANICAL;
          damaging_item.getTag repairKitTag Tag.ITEM_REPAIR_KIT;
          
          # debug_log "Damaging item's repairKit tag value is ";
          # debug_log repairKitTag;

          if and eq mechanicalTag 0 eq repairKitTag 1;
            battle_game.flashMessage "This unit is not a machine and cannot be healed with this!";
            return power part side;
          else and eq mechanicalTag 1 eq repairKitTag 1;
            set power 0;
            unit.getTag repairHPLimit Tag.UNIT_REPAIR_LIMIT;
            unit.getTag repairHPCurrent Tag.UNIT_CURRENT_REPAIR;
            if ge repairHPCurrent repairHPLimit;
              battle_game.flashMessage "This unit cannot be further repaired!";
              return power part side;
            else lt repairHPCurrent repairHPLimit;
              damaging_item.getTag repairKitPower Tag.ITEM_REPAIR_KIT_POWER;
              # debug_log "Below are repairkitPower and repairHPcurrent";
              # debug_log repairKitPower;
              # debug_log repairHPCurrent;
              
              set repairValue repairKitPower;
              add repairValue repairHPCurrent;
              # debug_log "Below is the sum of both: ";
              # debug_log repairValue;
              
              if gt repairValue repairHPLimit;
                sub repairHPLimit repairHPCurrent;
                set repairValue repairHPLimit;
                # debug_log "Since repairValue was greater than repairHPCurrent only the remaining HP will be applied as repairs, no excess";
                # unit.getTag repairHPLimit Tag.UNIT_REPAIR_LIMIT; #we're asking for it again since we modified earlier
                # unit.setTag Tag.UNIT_CURRENT_REPAIR repairHPLimit; #since we're maxing out the repair in this operation
              else le repairValue repairHPLimit;
                # debug_log "Since repairValue was lesser or equal to repairHPcurrent it will repair the amount equal to full repair power";
                # unit.setTag Tag.UNIT_CURRENT_REPAIR repairValue; #sum of repairkit power + current repaired HP
                set repairValue repairKitPower; #the actual amount we're healing!
              end;

              # debug_log "Amount to repair: ";
              # debug_log repairValue;
              unit.getHealth currHealth;
              # debug_log "Unit's current hp is ";
              # debug_log currHealth;
              unit.getHealthMax maxHealth;
              set healthValue currHealth;
              add healthValue repairValue;

              if gt healthValue maxHealth;
                unit.setHealth maxHealth; #since this will heal us to max anyways
                sub maxHealth currHealth; #This is the amount we will be adding to the currentHPRepaired
                # debug_log maxHealth;
                # debug_log "repair would've exceeded maxhealth, reduced repair value to above";
                # unit.getTag healthValue Tag.UNIT_REPAIR_LIMIT; #borrowing this so we can make the current repair equal to limit minus the exceeded hp that was not repaired
                # sub repairKitPower maxHealth; #This is the kit's power minus the amount we actually healed
                # sub healthValue repairKitPower; #This is the final Current Repair that should be updated, since we didn't exceed it yet                
                # unit.setTag Tag.UNIT_CURRENT_REPAIR healthValue;
                # unit.getTag healthValue Tag.UNIT_CURRENT_REPAIR; #borrowing this variable now that its unused
                # debug_log "updated total Current repaired is: ";
                # debug_log maxHealth;
                set healthValue maxHealth; #the value we will be passing below
              else le healthValue maxHealth;
                unit.setHealth healthValue;
                set healthValue repairKitPower;
              end;

              # debug_log "The final amount that will be healed is: ";
              # debug_log healthValue;
              # debug_log "The Current Repair HP out of the MAX for this unit is: ";
              unit.getTag repairValue Tag.UNIT_CURRENT_REPAIR;
              # debug_log repairValue;
              add repairValue healthValue;
              if ge repairValue 30;
                set repairValue 30;
              end;
              unit.setTag Tag.UNIT_CURRENT_REPAIR repairValue;
              # debug_log "Amount healed + Current Repair HP";
              # debug_log repairValue;
              battle_game.flashMessage "Repair Succesful!";
            end;
            return power part side;
          end;
          
          return power part side;

    recolorUnitSprite:
      - offset: 0.1 #Handles periodic recolors due to daze
        code: |
          var int frame;
          var int frameLength;
          var int dazeTag;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;
          var ptr RuleArmor armorRuleset;

          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.LAST_HIT_FRAME;
          set frameLength 6;
          set recolorPeriod 36;
 
          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              return new_pixel;
            end;

          end;

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          unit.getTag temp Tag.FTAG_ISDAZED;

          if and neq temp 0 lt frame frameLength;
            #set temp anim_frame;
            wavegen_tri frame 12 12 12;
            mul frame -1;
            add frame 6; #8;
            get_shade newShade new_pixel;
            sub newShade frame;

            if gt newShade 4;
              set_shade new_pixel newShade;
              else;
              set_shade new_pixel 4;
            end;


          end;

          return new_pixel;

      #*** Handles periodic recolors due to energy shields on units ***
      - offset: 1
        code: |
          var int frame;
          var int frameLength;
          var int recolorPeriod;
          var int desync;
          var int color;
          var int newShade;
          var int temp;
          var ptr RuleArmor armorRuleset;

          # Check to make sure this unit isn't set to be recolored by a hit first
          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;

            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;

              return new_pixel;

            end;

          end;

          set recolorPeriod 32;
          set frameLength 4;

          unit.getTag desync Tag.UNIT_RECOLOR_DESYNC;
          set frame anim_frame;
          add frame desync;
          mod frame recolorPeriod;

          # First, a blue flash if the unit has an energy shield
          unit.getTag temp Tag.UNIT_ENERGY_SHIELD_HP;

          if and neq temp 0 lt frame frameLength;

            unit.getRuleArmor armorRuleset;
            armorRuleset.getTag color Tag.ARMOR_ENERGY_SHIELD_FLASH_COLOR;

            if eq color 0;

              set color COLOR_X1_BLUE1;

            end;

            set temp frameLength;
            sub temp frame;
            mul temp 2; # a parameter that creates a nice flash animation
            get_shade newShade new_pixel;
            sub newShade temp;

            if and gt newShade 3 lt newShade 16;

              set_shade new_pixel newShade;
              set_color new_pixel color;

            end;

          end;

          return new_pixel;

      - offset: 10
        code: |
          var int frame;
          var int frameLength;
          var int color;
          var int newShade;
          var int temp;

          unit.getTag frame Tag.UNIT_RECOLOR_START_FRAME;
          unit.getTag frameLength Tag.UNIT_RECOLOR_FRAME_LENGTH;

          if neq frame 0;
            set temp anim_frame;
            sub temp frame;

            if lt temp frameLength;
              # Check shade, add some darkening decay, but don't recolor if it'd go too dark
              get_shade newShade new_pixel;
              mul temp 4;
              sub newShade temp;
              if or lt newShade 4 gt newShade 15;
                return new_pixel;
              end;

              unit.getTag color Tag.UNIT_RECOLOR_COLOR;
              set_color new_pixel color;
              set_shade new_pixel newShade;
            end;
          end;

          return new_pixel;

    recolorItemSprite:
      - offset: 10
        code: |
          var ptr RuleItem shieldItem;
          var int shieldCapacity;
          var int shieldNeedsPriming;
          var int shieldTimer;
          var int shieldHp;
          var int shieldPercent;
          var int shieldIsPrimed;
          var int color;
          var int colorToReplace;
          var int shadeIndex;
          var int temp;

          item.getRuleItem shieldItem;
          shieldItem.getTag shieldCapacity Tag.ITEM_ENERGY_SHIELD_CAPACITY;

          if eq shieldCapacity 0;
            return new_pixel;
          end;

          item.getTag shieldHp Tag.ITEM_ENERGY_SHIELD_HP;
          set shieldPercent shieldHp;
          muldiv shieldPercent 100 shieldCapacity;

          # Recolor behavior is based on shield type
          shieldItem.getTag shieldNeedsPriming Tag.ITEM_ENERGY_SHIELD_NEEDS_PRIMING;

          item.getFuseTimer shieldTimer;
          if and neq shieldNeedsPriming 0 gt shieldTimer 0; # Get shield percent for consumable shields
            item.getTag shieldIsPrimed Tag.ITEM_ENERGY_SHIELD_IS_PRIMED;

            if eq shieldIsPrimed 0; # Haven't been hit yet, but should show shield
              set shieldPercent 100;
            end;
          end;

          # Choose color to replace on sprite
          get_color color new_pixel;
          set temp 0;

          # Pick the color to replace from the ruleset tags
          shieldItem.getTag colorToReplace Tag.ITEM_ENERGY_SHIELD_COLOR_REPLACED_BY_INDICATOR;

          if eq color colorToReplace;
            get_shade shadeIndex new_pixel;

            shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_INDICATOR_COLOR;

            if eq shieldPercent 0; # Choose critical shields at 20%, make tag later?
              if and neq shieldNeedsPriming 0 gt shieldTimer 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_DOWN_COLOR;
              else eq shieldNeedsPriming 0;
                shieldItem.getTag temp Tag.ITEM_ENERGY_SHIELD_DOWN_COLOR;
              end;
            end;

            if eq temp 0; # Default color to blue if none is found
              set temp COLOR_X1_BLUE1;
            end;

            set color temp;

            set temp shieldPercent;
            sub temp 100;
            abs temp;
            muldiv temp 15 100;
            add shadeIndex temp;
            limit shadeIndex 0 15;
            set_color new_pixel color;
            set_shade new_pixel shadeIndex;
          end;

          return new_pixel;        

    returnFromMissionUnit:
#*** Handles extra secondary experience gain due to tagged armors ***
      - offset: 1
        code: |
          var ptr RuleArmor soldierArmor;
          var ptr RuleSoldier soldierRuleset;
          var int extraExperiencePercentage;
          var int expTotal;
          var int statCurrent;
          var int statCap;
          var int statBonus;

          unit.getRuleArmor soldierArmor;
          soldierArmor.getTag extraExperiencePercentage Tag.ARMOR_GAINS_EXTRA_SECONDARY_STATS_PERCENT;
 
          set expTotal 0;

          unit.Exp.getBravery statCurrent;
          add expTotal statCurrent;

          unit.Exp.getFiring statCurrent;
          add expTotal statCurrent;

          unit.Exp.getMelee statCurrent;
          add expTotal statCurrent;

          unit.Exp.getPsiSkill statCurrent;
          add expTotal statCurrent;

          unit.Exp.getPsiStrength statCurrent;
          add expTotal statCurrent;

          unit.Exp.getReactions statCurrent;
          add expTotal statCurrent;

          unit.Exp.getStrength statCurrent;
          add expTotal statCurrent;

          unit.Exp.getThrowing statCurrent;
          add expTotal statCurrent;

          if or eq 0 extraExperiencePercentage eq 0 expTotal;
            return;
          end;

          unit.getRuleSoldier soldierRuleset;
          soldier.Stats.getTimeUnits statCurrent;
          soldierRuleset.StatsCap.getTimeUnits statCap;
          if le statCurrent statCap;
            set statBonus statCap;
            sub statBonus statCurrent;
            muldiv statBonus extraExperiencePercentage 100;
            limit_lower statBonus 1;
            battle_game.randomRange statBonus 0 statBonus;
            add statBonus statCurrent;
            soldier.Stats.setTimeUnits statBonus;
          end;

          soldier.Stats.getStamina statCurrent;
          soldierRuleset.StatsCap.getStamina statCap;
          if le statCurrent statCap;
            set statBonus statCap;
            sub statBonus statCurrent;
            muldiv statBonus extraExperiencePercentage 100;
            limit_lower statBonus 1;
            battle_game.randomRange statBonus 0 statBonus;
            add statBonus statCurrent;
            soldier.Stats.setStamina statBonus;
          end;

          soldier.Stats.getHealth statCurrent;
          soldierRuleset.StatsCap.getHealth statCap;
          if le statCurrent statCap;
            set statBonus statCap;
            sub statBonus statCurrent;
            muldiv statBonus extraExperiencePercentage 100;
            limit_lower statBonus 1;
            battle_game.randomRange statBonus 0 statBonus;
            add statBonus statCurrent;
            soldier.Stats.setHealth statBonus;
          end;

          soldier.Stats.getStrength statCurrent;
          soldierRuleset.StatsCap.getStrength statCap;
          if le statCurrent statCap;
            set statBonus statCap;
            sub statBonus statCurrent;
            muldiv statBonus extraExperiencePercentage 100;
            limit_lower statBonus 1;
            battle_game.randomRange statBonus 0 statBonus;
            add statBonus statCurrent;
            soldier.Stats.setStrength statBonus;
          end;

          return;
